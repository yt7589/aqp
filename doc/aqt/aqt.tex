\documentclass{article}
\usepackage{xeCJK}
% if you need to pass options to natbib, use, e.g.:
%\PassOptionsToPackage{numbers, compress}{natbib}
% before loading nips_2017
%
% to avoid loading the natbib package, add option nonatbib:
% \usepackage[nonatbib]{nips_2017}

\usepackage[final]{nips_2017}

% to compile a camera-ready version, add the [final] option, e.g.:
% \usepackage[final]{nips_2017}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{bm}             % bold in math
\usepackage{graphicx}       % images
\usepackage{algorithm}      % algorithm
\usepackage[noend]{algpseudocode} % algorithm
\usepackage{caption}        % captionof
\usepackage{array}          % thick column hline
\usepackage{booktabs}       % table style
\usepackage{pbox}           % table line break
\usepackage{subcaption}     % multiple figures
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{amsmath}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{codeBkg}{rgb}{0.85,0.85,0.85}

\lstset{ 
	backgroundcolor=\color{codeBkg},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=no,	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=Octave,                 % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\title{高级量化交易技术}

\hypersetup{
    colorlinks = true,
}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcolumntype{?}{!{\vrule width 3pt}}

\author{
  闫涛 \\
  %% examples of more authors
  %% \And
  %% Nicholas Frosst \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
  %% \AND
  %% Geoffrey E. Hinton \\
  科技有限公司\\
  北京 \\
  \texttt{\{yt7589\}@qq.com} \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
  %% \And
  %% Coauthor \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
  %% \And
  %% Coauthor \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
}
\date{March 2018}

% \usepackage{natbib}
% \usepackage{graphicx}

\begin{document}






\maketitle
\begin{center}
\Large \textbf{第1章} \quad \textbf{时间序列基本特性}
\end{center}
\begin{abstract}
在本章中我们将讨论时间序列的基本特性，包括自相关性和平稳性。
\end{abstract}
\section{时间序列基本特性}
时间序列的自相关性是指时间序列过去与未来存在某种关系，是我们时间序列预测的基础。主要用自协方差函数（Autocovariance Function, AF）、自相关系数函数（Autocorrelation Coefficent Function, ACF）和偏自相关系数函数（Partial Autocorrelation Coefficient Function, PACF）来描述。
\subsection{随机变量统计量}
随机变量X其取值为$x$的均值定义为：
\begin{equation}
E(x) = \mu
\label{e000001}
\end{equation}
方差定义为：
\begin{equation}
\sigma ^{2} (x) = E\bigg[ \big( x - \mu \big)^{2} \bigg]
\label{e000002}
\end{equation}
其中$\sigma (x)$为标准差。
对于两个随机变量$x$和$y$，其协方差可以定义为：
\begin{equation}
\sigma (x, y) = E\bigg[ \big( x - \mu _{x} \big) \big( y - \mu _{y} \big) \bigg]
\label{e000003}
\end{equation}
在实际应用中，我们不可能知道真实的均值，只能使用统计量，因此协方差可以定义为：
\begin{equation}
Cov(x, y) = \frac{1}{n-1} \sum_{i=1}^{n} (x_{i} - \bar{x})(y_{i} - \bar{y})
\label{e000004}
\end{equation}
随机变量$x$和$y$的相关系数定义为：
\begin{equation}
\rho(x,y)=\frac{E[(x-\mu_{x})(y-\mu_{y})]}{\sigma _{x} \sigma _{y}}=\frac{\sigma(x,y)}{\sigma _{x} \sigma _{y}}
\label{e000005}
\end{equation}
采用统计量的表示方法为：
\begin{equation}
Cor(x,y)=\frac{Cov(x,y)}{std(x) \times std(y)}
\label{e000006}
\end{equation}
以上我们讨论的都是不同随机变量之间的关系，对于时间序列来说，我们可以把从不同时间点开始的子时间序列，视为不同的随机变量，那么我们就可以定义自协方差、自相关系数函数和偏自相关系数函数了。\newline
\subsection{时序序列平稳性}
时序信号$x_{t}$的均值定义为：
\begin{equation}
E(x_{t})=\mu (t)
\label{e000007}
\end{equation}
时间序列的均值与所考虑的时间点有关。我们可以把时间序列上每个时间点都视为一个独立的时间变量，但是对于时间序列而言，每个时间点的随机变量只有一个观测值，怎么求出均值呢？在实际应用中，我们会将时间序列中的趋势信号（上涨或下跌）、季节性信号等从时间序列中去除掉，对于剩下的残差序列，我们可以视为其各个时间点上的随机变量的均值是不变的，于是就可以使用下面的公式来计算均值：
\begin{equation}
\bar{x}=\frac{1}{N} \sum_{t=1}^{N}x_{t}
\label{e000008}
\end{equation}
由此我们引入平稳时间序列的概念，对于平稳时间序列，其各个时间点上对应的随机变量的均值相等。
时间序列的方差可以定义为：
\begin{equation}
\sigma ^{2}(t)=E[(x_{t}-\mu _t)^{2}]
\label{e000009}
\end{equation}
根据上面平稳时间序列的定义，各个时间点对应的随机变量的均值不变，则式\ref{e000009}可以化间为：
\begin{equation}
\sigma ^{2}(t)=E[(x_{t}-\mu)^{2}]
\label{e000010}
\end{equation}
我们同时规定，平稳时间序列各个时间点对应的随机变量的方差也不变，则\ref{e000010}可进一步化简为：
\begin{equation}
Var(x_{t})=\frac{1}{N-1} \sum_{t=1}{N} (x_t - \bar{x})^{2}
\label{e000011}
\end{equation}
\subsection{自协方差}
在讨论自协方差之前，我们首先要定义二阶平稳性。根据上一节定义，平稳时间序列是指各个时间点对应的随机变量的均值和方差相同。二阶平稳性是指在这一基础上，不同时间点对应的随机变量的相关系数只与时间相隔（lag）相关。注意：以下我们讨论的各种性质，均以此为前提。
对于lag=k的自协方差定义为：
\begin{equation}
C_{k}=E[(x_{t} - \mu)(x_{t+k} - \mu)]
\label{e000012}
\end{equation}
\subsection{自相关系数函数ACF}
由于自协方差的大小与随机变量的大小有关，无法准确衡量其间的关系，因此我们引入自相关系数函数ACF：
\begin{equation}
\rho _{k} = \frac{C_{k}}{\sigma ^{2}}
\label{e000013}
\end{equation}
由定义可知：
\begin{equation}
\begin{aligned}
\rho _{0} = \frac{C_{0}}{\sigma ^{2}} = \frac{E[(x_{t} - \mu)(x_{t} - \mu)]}{\sigma ^{2}} \\
= \frac{E[(x_{t} - \mu)^{2}]}{\sigma ^{2}} = \frac{\sigma ^{2}}{\sigma ^{2}} = 1\\
\end{aligned}
\label{e000014}
\end{equation}
在实际应用中，我们都是处理的离散数据点，则自协方差可以定义为：
\begin{equation}
c_{k}=\frac{1}{N}\sum_{t=1}^{N}(x_{t}-\bar{x})(x_{t+k} - \bar{x})
\label{e000015}
\end{equation}
自相关系数函数ACF可以定义为：
\begin{equation}
r_{k}=\frac{c_{k}}{c_{0}}
\label{e000016}
\end{equation}
\subsection{自相关性举例}
下面我们以上证综指时间序列为例，来看自相关系数函数ACF和偏自相关系数函数PACF的求法和作图，程序代码如下所示：
\lstset{language=PYTHON, caption={时间序列基本性质}, label={c000001}}
\begin{lstlisting}
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.font_manager import FontProperties
from statsmodels.tsa import stattools
from statsmodels.graphics import tsaplots

class Chp023(object):
    def __init__(self):
        self.name = 'Chp022'
        # 数据文件格式：编号 日期 星期几 开盘价 最高价 
        # 最低价 收益价 收益
        self.data_file = 'data/pqb/chp023_001.txt'
        
    def startup(self):
        print('第23章：时间序列基本性质')
        data = pd.read_csv(self.data_file, sep='\t', index_col='Trddt')
        sh_index = data[data.Indexcd==1]
        sh_index.index = pd.to_datetime(sh_index.index)
        sh_return = sh_index.Retindex
        print('时间序列长为：N={0}'.format(len(sh_return)))
        acfs = stattools.acf(sh_return)
        print(acfs)
        pacfs = stattools.pacf(sh_return)
        print(pacfs)
        tsaplots.plot_acf(sh_return, use_vlines=True, lags=30)
        plt.show()
        tsaplots.plot_pacf(sh_return, use_vlines=True, lags=30)
        plt.show()
\end{lstlisting}
数据文件格式为：
\begin{figure}[H]
	\caption{数据文件格式}
	\label{f000001}
	\centering
	\includegraphics[height=3cm]{images/f000001}
\end{figure}
其运行结果为：
\begin{figure}[H]
	\caption{运行结果}
	\label{f000002}
	\centering
	\includegraphics[height=3cm]{images/f000002}
\end{figure}
在图\ref{f000002}中，第一个数据为自相关系数函数ACF各期的值，而第二个数组为偏自相关系数函数PACF各期的值。判断时间序列是否具有自相关性，可以看除ACF和PACF中，除第一个元素外，有没有显著超过阈值的元素，阈值定义为：
\begin{equation}
threshold=\frac{1.96}{\sqrt{N}} = \frac{1.96}{\sqrt{311}} = 0.11
\label{e000017}
\end{equation}
式\ref{e000017}中的N为时间序列样本数，在本例中，共有311条记录，故N=311，所以其阈值为0.11左右。由于$acf[4]=0.16>0.11$所以可以推断其具有自相关性，同时$pacf[4]=0.165>0.11$也可以推断其具有自相关性。我们还可以通过图形的方式形像的表示出来，自相关系数函数图如所示：
\begin{figure}[H]
	\caption{自相关系数函数图}
	\label{f000003}
	\centering
	\includegraphics[height=4cm]{images/f000003}
\end{figure}
图\ref{f000003}中蓝色区域的界限为$[-\frac{1.96}{\sqrt{N}}, \frac{1.96}{\sqrt{N}}]=[-0.11, 0.11]$，除第1项外，其他项如果超出蓝色区域则说明此时间序列具有自相关性。\newline
偏自相关系数函数图为：
\begin{figure}[H]
	\caption{偏自相关系数函数图}
	\label{f000004}
	\centering
	\includegraphics[height=4cm]{images/f000004}
\end{figure}
\subsection{白噪声和随机游走}
\subsubsection{残差序列定义}
我们要对任意时间序列$y_{t}$进行建模，我们的模型为$\hat{y}_{t}$，残差序列$x_{t}$可以定义为：$x_{t}=y_{t}-\hat{y}_{t}$，我们的任务就是使残差时间序列中每一个时间点对应的随机变量互相独立，没有自相关性，即满足独立同分布（Independent and Identical Distribution,I.I.D）条件。如果各个随机变量$x_{t} \sim \mathbb{N}(0, \sigma ^{2})$，则称其为高斯白噪声。\newline
\subsubsection{差分运算符}
为了后续讨论问题方便，我们首先定义BSO运算符：
\begin{equation}
Bx_{t}=x_{t-1} \quad B^{n}x_{t}=x_{t-n}
\label{e000018}
\end{equation}
我们定义差分运算符为：
\begin{equation}
\begin{aligned}
\nabla x_{t} = x_{t}-x_{t-1}=(1-B)x_{t} \\
\nabla x_{t}^{n} = \big( x_{t}-x_{t-n} \big)^{n}=(1-B)^{n}x_{t}
\end{aligned}
\label{e000019}
\end{equation}
\subsubsection{白噪声定义}
对于时间序列$\{ w_{t}, t=1,2,3,...,N \}$，满足$\forall t \quad w_{t} \sim \mathcal{N}(0, \sigma ^{2})$且$\forall i \ne j \quad Cor(w_{i}, w_{j})=0$，则其为白噪声时间序列。\newline
下面我们来看白噪声的二阶属性：
\begin{equation}
\begin{aligned}
\mu = E(w_{t})=0 \\
\gamma _{k}= Cor(w_{t}, w_{t+k}) = \begin{cases}
1 \quad if \quad k=0 \\
0 \quad if \quad k \ne 0
\end{cases}
\end{aligned}
\label{e000020}
\end{equation}
\subsubsection{随机游走}
随机游走（Random Walk）时间序列是指$x_{t}$可以定义为：$x_{t}=x_{t-1}+w_{t}$，其中$w_{t}$为白噪声时间序列。随机游走时间序列可以表示为：
\begin{equation}
\begin{aligned}
x_{t}=x_{t-1}+w_{t}=Bx_{t}+w_{t} \\
x_{t}=x_{t-1}+w_{t}=x_{t-2}+w_{t-1}+w_{t} \\
...... \\
x_{t}=w_{1} + w_{2} + ... + w_{t-1} + w_{t}
\end{aligned}
\label{e000021}
\end{equation}
所以随机游走时间序列可以看作是多个白噪声时间序列的叠加。下面我们来看随机游走时间序列的均值和协方差：
\begin{equation}
\begin{aligned}
\mu = 0 \\
\gamma _{k}(t)=Cov(x_{t}, x_{t+k})=t \sigma ^{2}
\end{aligned}
\label{e000022}
\end{equation}
我们再来看随机游走序列的自相关系数函数ACF：
\begin{equation}
\begin{aligned}
\rho _{k}(t)=\frac{Cov(x_{t}, x_{t+k})}{\sqrt{ Var(x_{t}) \cdot Var(x_{t+k}) }} \\
=\frac{t \sigma ^{2}}{\sqrt{t \sigma ^{2} (t+k) \sigma ^{2}}}=\frac{1}{\sqrt{1+ \frac{k}{t} }}
\end{aligned}
\label{e000023}
\end{equation}
在通常情况下，t比k要大得多，因此$\rho_{k}$会比较接近于1。\newline
下面我们来模拟一个随机游走时间序列信号，程序如下所示：
\lstset{language=PYTHON, caption={随机游走过程模拟}, label={c000003}}
\begin{lstlisting}
    def random_wale_demo(self):
        '''
        随机游走时间序列建模示例
        '''
        w = np.random.standard_normal(size=1000)
        x = w
        for t in range(1, len(w)):
            x[t] = x[t-1] + w[t]
        plt.plot(x, c='b')
        plt.title('Random Walk Demo')
        plt.show()
        acfs = stattools.acf(x)
        print(acfs)
        tsaplots.plot_acf(x, use_vlines=True, lags=30)
        plt.show()
        # 拟合随机游走信号
        r = []
        for t in range(1, len(x)):
            r.append(x[t] - x[t-1])
        rd = np.array(r)
        plt.plot(rd, c='r')
        plt.title('Residue Signal')
        plt.show()
        rd_acfs = stattools.acf(rd)
        print(rd_acfs)
        tsaplots.plot_acf(rd, use_vlines=True, lags=30)
        plt.show()
\end{lstlisting}
我们首先通过$x_{t}=x_{t-1}+w_{t}$生成一个随机游走信号，该信号图形如下所示：
\begin{figure}[H]
	\caption{随机游走时间序列信号}
	\label{f000005}
	\centering
	\includegraphics[height=5cm]{images/f000005}
\end{figure}
由图\ref{f000005}可以看出，其非常像是一个股票收盘价的走势图，这也是为什么有些人说股票走势是随机游走过程了。接着我们求出该时间序列的自相关系数函数ACF及其自相关图，如下所示：
\begin{figure}[H]
	\caption{随机游走时间序列信号}
	\label{f000006}
	\centering
	\includegraphics[height=5cm]{images/f000006}
\end{figure}
由图可以看出，其具有极强的自相关性，所有ACF值均位于蓝色置信区间之外。\newline
我们知道$x_{t}-x_{t-1}=w_t$，而$w_t$是白噪声时间序列信号，这实际上模拟了实际应用过程，我们把$x_t$视为实际的金融信号，而$x_{t-1}$为我们建模的信号，将两个信号相减，得到残差信号，如果残差信号是白噪声信号，就可以认为我们建模是合理的。下面来看我们得到的残差信号：
\begin{figure}[H]
	\caption{残差时间序列信号}
	\label{f000007}
	\centering
	\includegraphics[height=5cm]{images/f000007}
\end{figure}
计算并绘制ACF如下所示：
\begin{figure}[H]
	\caption{残差自相关系数函数}
	\label{f000008}
	\centering
	\includegraphics[height=5cm]{images/f000008}
\end{figure}
程序的运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000009}
	\centering
	\includegraphics[height=5cm]{images/f000009}
\end{figure}
下面我们以上证综指收益率为例，来看随机游走模型是否可以很好的拟合这个时间序列，程序如下所示：
\lstset{language=PYTHON, caption={随机游走拟合上证综指收益率}, label={c000004}}
\begin{lstlisting}
    def random_walk_fit(self):
        data = pd.read_csv(self.data_file, sep='\t', index_col='Trddt')
        sh_index = data[data.Indexcd==1]
        sh_index.index = pd.to_datetime(sh_index.index)
        sh_return = sh_index.Retindex
        print('时间序列长为：N={0}'.format(len(sh_return)))
        r = []
        for t in range(1, len(sh_return)):
            r.append(sh_return[t] - sh_return[t-1])
        rd = np.array(r)
        plt.plot(rd, c='b')
        plt.title('Random Walk fit SHIndex Return')
        plt.show()
        rd_acfs = stattools.acf(rd)
        print(rd_acfs)
        tsaplots.plot_acf(rd, use_vlines=True, lags=30)
        plt.show()
\end{lstlisting}
其残差图像为：
\begin{figure}[H]
	\caption{残差图形}
	\label{f000010}
	\centering
	\includegraphics[height=5cm]{images/f000010}
\end{figure}
自相关系数函数ACF图形：
\begin{figure}[H]
	\caption{自相关系数函数ACF}
	\label{f000011}
	\centering
	\includegraphics[height=5cm]{images/f000011}
\end{figure}
由图\ref{f000011}所示，在1、4时间点，明显超出置信范围，因此随机游走过程不能很好的拟合上证综指收益率时间序列信号。程序的运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000012}
	\centering
	\includegraphics[height=5cm]{images/f000012}
\end{figure}

\maketitle\begin{center}
\Large \textbf{第2章 ARIMA模型}
\end{center}
\begin{abstract}
在本章中我们将首先讲述自回归模型AR(p)，接着讲述移动平均MA(q)，最后讲解ARMA(p,q)，然后将其泛化为ARIMA(p,d,q)，
分别将这些模型用于实际金融时间序列数据拟合。aqt001.py
\end{abstract}
\section{ARIMA模型}
\subsection{稳定性和模型选择标准}
\subsubsection{强稳定性}
在我们以前的讨论中，我们说如果一个时间序列各个时间点所对应的随机变量，只要均值和方差不变，就是平稳时间序列。下面我们对强平稳性进行定义。\newline
对于一个时间序列$\{ x_{t} \}$，如果对于$\forall t_{i},m$，两个序列：$x_{t_1}, x_{t_2},...,x_{t_N}$和$x_{t_1+m}, x_{t_2+m},...,x_{t_N+m}$的统计特性完全相同，则说明该时间序列为强平稳特性。
\subsubsection{模型选择标准}
我们将用AIC来进行模型选择，AIC的全称为：Akaike Information Criterion，我们通常会选择AIC值较小的模型。在实际应用中，还可以使用BIC来进行模型选择，BIC的全称为Bayes Information Criterion。在本章中我们只用AIC来进行模型选择。\newline
假设统计模型的似然函数有$k$参数，最大似然值为$L$，则AIC定义为：
\begin{equation}
AIC=-2\log(L) + 2k
\label{e000024}
\end{equation}
由式\ref{e000024}可知，最大似然值越大或者参数越少，AIC的值越小，模型就越是好模型。
\subsubsection{ADF检验}
在前面所讨论的问题中，我们通常根据自相关系数函数ACF和偏自相关系数函数PACF来判断稳定性，但是主观性比较强，我们需要一个客观的标准。\newline
我们首先来定义时间序列的阶数，对于下面的非平稳时间序列：
\begin{equation}
x_{t}=x_{t-1}+w_{t}
\label{e000036}
\end{equation}
其中$w_{t} \sim \mathcal{N}(0, \sigma ^{2})$为白噪声信号，且$x_{0}=0$,我们可以得到其均值为：
\begin{equation}
E(x_{t})=E(x_{t-1}+w_{t})=E(x_{t-1})+E(w_{t})=E(x_{t-1})=...=E(x_{0})=0
\label{e000037}
\end{equation}
同样我们可以得到其方差：
\begin{equation}
Var(x_{t})=Var(x_{t-1}+w_{t})=Var(x_{t-1})+Var(w_{t})=Var(x_{t-1})+\sigma ^{2}=...=t\sigma ^{2}
\label{e000038}
\end{equation}
$x_{t}$由于其各时间点对应的随机变量的方差随时间变化，因此不是平稳时间序列。\newline
我们定义1阶差分算子：
\begin{equation}
\nabla x_{t} = Bx_{t}=x_{t}-x_{t-1}=w_{t}
\label{e000039}
\end{equation}
对于$Bx_{t}$为白噪声信号，其显然是平稳时间序列，所以我们称$x_{t}$为I(1)的非平稳时间序列。我们可以将其定义扩展到$n$阶：
\begin{equation}
Bx_{t}=x_{t-1} \quad B^{2}x_{t}=x_{t-2} \quad B^{3}x_{t}=x_{t-3} \quad ...  \quad B^{n}x_{t}=x_{t-n}
\label{e000040}
\end{equation}
我们还以上面的时间序列$x_{t}=x_{t-1}+w_t$为例，我们可以将其写为：
\begin{equation}
x_{t}-x_{t-1}=x_{t}-Bx_{t}=(1-B)x_{t}=w_{t}
\label{e000041}
\end{equation}
式\ref{e000041}中$1-B$为滞后算子多项式，我们令$1-B=0$得出的解为$B=1$，其为单位根，所以其为非平稳时间序列。这一结论可以推广到更一般的情况，对于如下所示的时间序列：
\begin{equation}
y_{t}=(1+\rho)y_{t-1}-\rho y_{t-2}+w_{t}
\label{e000042}
\end{equation}
其所对应的滞后算子多项式为：
\begin{equation}
y_{t}-(1-\rho)By_{t}+\rho B^{2} y_{t}=w_{t}
\label{e000043}
\end{equation}
令式\ref{e000043}左边为0，得到的解为：$B=1$和$B=\frac{1}{\rho}$，因为其存在单位根，所以其不是平稳时间序列。\newline
对于任意如下所示时间序列：
\begin{equation}
y_{t}=\gamma + \rho _{1}y_{t-1} + \rho _{2}y_{t-2} + ... + \rho _{p}y_{t-p} + w_{t}
\label{e000044}
\end{equation}
其中$w_{t} \sim \mathcal{N}(0, \sigma ^{2})$为独立同分布（i.i.d）噪声信号。
可以将式\ref{e000044}改写为如下形式：
\begin{equation}
y_{t}=\gamma + \rho _{1}By_{t} + \rho _{2}B^{2}y_{t} + ...  + \rho _{p}B^{p}y_{t} + w_{t}
\label{e000045}
\end{equation}
将式\ref{e000045}右边所有包含$y_{t}$的项都移到左边，可以得到下式：
\begin{equation}
(1-\rho _{1}B - \rho _{2}B^{2} - .. - \rho _{p}B^{p})y_{t}=\gamma + w_{t}
\label{e000046}
\end{equation}
可以得到其对应的滞后算子多项式方程为：
\begin{equation}
1-\rho(B)=1-\rho _{1}B - \rho _{2}B^{2} - .. - \rho _{p}B^{p}=0
\label{e000047}
\end{equation}
解这个方程，如果所有解的绝对值均大于1，则该时间序列为平稳时间序列，如果存在单位根或绝对值小于1的根，则其为非平稳时间序列。\newline
以上我们讲解的判断时间序列平稳性的原理，在实际应用中，我们通常采用ADF来判断时间序列的平稳性，ADF模型如下所示：
\begin{equation}
\Delta y_{t}=\alpha + \beta t + \gamma y_{t-1} + \delta _{1}\Delta y_{t-1} + \delta _{2}\Delta y_{t-2} + ... + \delta _{p}\Delta y_{t-p} + w_{t}
\label{e000048}
\end{equation}
其中$\alpha$对应截距，$\beta$对应趋势，$\delta _{1}\Delta y_{t-1} + \delta _{2}\Delta y_{t-2} + ... + \delta _{p}\Delta y_{t-p}$为ADF的增广项，p为增广项的期数，其值由AIC或BIC算法来决定。原假设$H_{0}$为该序列有单位根是非平稳时间序列：$\gamma = 0$；备择假设$H_{1}$为该序列为平稳时间序列：$\gamma < 0$。\newline
这部分原理比较复杂，我们在实际应用中，通常使用arch包中的ADF函数来完成检验工作，其函数定义为：
\begin{equation}
ADF(y, lags, trend, max_lags, method)
\label{e000049}
\end{equation}
其中：
\begin{itemize}
\item y：待判断的时间序列；
\item lags：滞后期数
\item trend：用来控制检验模型的类型
	\begin{itemize}
	\item 'nc'：不含截距项；
	\item 'c'：含截距项；
	\item 'ct'：包含截距项和线性趋势项；
	\item 'ctt'：包含截距项和线性趋势项以及二次趋势项；
	\end{itemize}
\item max\_lags：最大期数
\item method：常用方法为：'aic'、 'bic'、 't\_stat'
\end{itemize}
下面我们通过一个例子来看怎样使用ADF方法，我们以上证综指收益率和收盘价这两个序列为例，我们首先需要安装python的garch库：
\lstset{language=BASH}
\begin{lstlisting}
pip install arch
\end{lstlisting}
程序代码如下所示：
\lstset{language=PYTHON, caption={ADF检验}, label={c000006}}
\begin{lstlisting}
import arch.unitroot as unitroot
......
    def adf_demo(self):
        print('ADF检验例程...')
        data = pd.read_csv(self.data_file, sep='\t', index_col='Trddt')
        sh_index = data[data.Indexcd==1]
        sh_index.index = pd.to_datetime(sh_index.index)
        sh_return = sh_index.Retindex
        sh_return_adf = unitroot.ADF(sh_return)
        print(sh_return_adf.summary().as_text())
        print('stat={0:0.4f}; pvalue={0:0.4f}'.format(sh_return_adf.stat, sh_return_adf.pvalue))
        print('critical_values:{0}'.format(sh_return_adf.critical_values))
        print('1%value={0}'.format(sh_return_adf.critical_values['1%']))
        if sh_return_adf.stat < sh_return_adf.critical_values['1%']:
            print('上证综指收益率为平稳时间序列 ^_^')
        else:
            print('上证综指收益率为平稳时间序列  !!!!!!!!!')
        sh_close = sh_index.Clsindex
        sh_close_adf = unitroot.ADF(sh_close)
        if sh_close_adf.stat < sh_close_adf.critical_values['1%']:
            print('上证综指收盘价为平稳时间序列 ^_^')
        else:
            print('上证综指收盘价为非平稳时间序列 ！！！！！！！')
\end{lstlisting}
运行结果如下所示：
\begin{figure}[H]
	\caption{自相关系数函数ACF}
	\label{f000022}
	\centering
	\includegraphics[height=5cm]{images/f000022}
\end{figure}
由上面的结果可以看出，上证综指收益率是稳定的时间序列，收盘价却是不稳定的时间序列。
\subsection{自回归模型}
\subsubsection{背景}
我们可以扩展随机游走模型，使当前时间点数据不仅依赖前一时间点的值，同时还依赖前p个时间点的值，是这p个值的线性组合，
这就得到了自回归模型。
\subsubsection{模型定义}
自回归模型AR(p)是随机游走模型的扩展，p阶自回归模型定义为：
\begin{equation}
x_{t}=\alpha _{1}x_{t-1} + \alpha _{2}x_{t-2} + ... + \alpha _{p}x_{t-p} + w_{t} = \sum_{i=1}^{p} \alpha _{i}x_{t-i} + w_{t}
\label{e000025}
\end{equation}
其中$\{ w_{t} \}$为白噪声，$\alpha _{i} \in R$且$\alpha_{p} \ne 0$。\newline
当$p=1$且$\alpha _{1}=1$时，自回归模型就退化为随机游走模型。\newline
为后续讨论方便，我们定义如下运算符：
\begin{equation}
\theta _{p}(B)x_{t}=(1-\alpha _{1}B-\alpha _{2}B^{2}-...-\alpha _{p}B^{p})x_{t}=w_{t}
\label{e000026}
\end{equation}
有了上述模型之后，我们就可以直接拿来作预测，如下所示：
\begin{equation}
\begin{aligned}
    \hat{x}_t=\alpha _{1}x_{t-1}+\alpha _{2}x_{t-2}+...+\alpha _{p}x_{t-p} \\
    \hat{x}_{t+1}=\alpha _{1}\hat{x}_{t}+\alpha _{2}x_{t-1}+...+\alpha _{p}x_{t-p+1}
\end{aligned}
\label{e000027}
\end{equation}
然后依此类推，可以求出其后n个时间点的预测值。
\subsubsection{二阶特性}
我们首先定义特性方程：
\begin{equation}
\theta _{p}(B)=0
\label{e000028}
\end{equation}
解这个方程得到的解的绝对值必须大于才是平稳序列。我们可以举几个实例，首先是随机游走序列：
\paragraph{随机游走}
根据定义$x_{t}=x_{t-1}+w_{t}$我们可以得到$\alpha _1=1$，其特性方程为$\theta=1-B=0$，其解为$B=1$，因为其解的
绝对值不大于1，所以其不是平稳模型。
\paragraph{1阶自回归}
我们假设自回归模型为$x_{t}=\frac{1}{4}x_{t-1}+w_{t}$，其中$\alpha _1=\frac{1}{4}$，
其特性方程为$\theta = 1-\frac{1}{4}=0$，其解为$B=4$，该解绝对值大于1，所以其是平稳模型。
\paragraph{2阶自回归模型}
我们假设自回归模型为$x_{t}=\frac{1}{2}x_{t-1}+\frac{1}{2}x_{t-2}+w_{t}$，其特性方程为
$\theta _2(B)=\frac{1}{2}(1-B)(B+2)=0$，则其解为$B=1,-2$，其中一个解为单位根，其绝对值不大于1，因此本模型不是
平稳模型。虽然本模型不是平稳模型，但是其他2阶自回归模型是完全有可能是平稳模型的。
\paragraph{二阶特性}
均值、自协方差、自相关系数定义如下所示：
\begin{equation}
\begin{aligned}
\mu _{x}=E(x_{t})=0 \\
\gamma _{k}=\sum_{i=1}^{p}\alpha _{i} \gamma _{k-i}, \quad k>0 \\
\rho _{k} = \sum_{i=1}^{p}\alpha _{i} \rho _{k-i}, \quad k>0
\end{aligned}
\label{e000029}
\end{equation}
\subsubsection{模拟数据}
下面我们来模拟一个AR(2)的时间序列，我们的数据生成和拟合代码如下所示：
\lstset{language=PYTHON, caption={AR数据模拟和拟合示例}, label={c000004}}
\begin{lstlisting}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.font_manager import FontProperties
from statsmodels.tsa import stattools
from statsmodels.graphics import tsaplots
from statsmodels.tsa.arima_model import ARIMA

class Aqt001(object):
    def __init__(self):
        self.name = 'Aqt001'
        
    def startup(self):
        print('ARMA模型...')
        self.simulate_ar2()
        
    def simulate_ar2(self):
        print('模拟AR(2)')
        alpha1 = 0.666
        alpha2 = -0.333
        wt = np.random.standard_normal(size=1000)
        x = wt
        for t in range(2, len(wt)):
            x[t] = alpha1 * x[t-1] + alpha2 * x[t-2] + wt[t]
        plt.plot(x, c='b')
        plt.show()
        ar2 = stattools.ARMA(x, (2, 0)).fit(disp=False)
        print('p={0} **** {1}; q={2}***{3}; {4} - {5} - {6}'.format(
                    ar2.k_ar, ar2.arparams, ar2.k_ma, ar2.maparams, 
                    ar2.aic, ar2.bic, ar2.hqic)
        )
        arima2_0_0 = ARIMA(x, order=(2, 0, 0)).fit(disp=False)
        print('ARIMA: p={0} **** {1}; q={2}***{3}; {4} - {5} - {6}'. \
                    format(arima2_0_0.k_ar, arima2_0_0.arparams, 
                    arima2_0_0.k_ma, arima2_0_0.maparams, 
                    arima2_0_0.aic, arima2_0_0.bic, 
                    arima2_0_0.hqic)
        )
        resid = arima2_0_0.resid
        # 绘制ACF
        acfs = stattools.acf(resid)
        print(acfs)
        tsaplots.plot_acf(resid, use_vlines=True, lags=30)
        plt.title('ACF figure')
        plt.show()
        pacfs = stattools.pacf(resid)
        print(pacfs)
        tsaplots.plot_pacf(resid, use_vlines=True, lags=30)
        plt.title('PACF figure')
        plt.show()
\end{lstlisting}
我们首先生成一个1000个数据点的均值为0方差为1的白噪声数据，然后根据$x_{t}=\alpha _{1}x_{t-1} + \alpha _{2}x_{t-2} + w_{t}=0.666 \times x_{t-1} - 0.333 \times x_{t-2} + w_{t}$公式，生成拟合数据。我们绘制该模拟数据图像，接着我们分别用ARMA和ARIMA进行拟合，求出系数，然后计算出模拟选择的参数：AIC、BIC、HQIC的值，最后我们求出模型拟合的残差，并绘制出残差自相关系数函数ACF和偏自相关系数函数PACF的图像。
模拟数据图像为：
\begin{figure}[H]
	\caption{AR2模拟生成数据图}
	\label{f000013}
	\centering
	\includegraphics[height=5cm]{images/f000013}
\end{figure}
无论是ARMA还是ARIMA拟合，我们都可以得到较为正确的数据，同时残差的ACF和PACF也表明其是白噪声序列，运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000014}
	\centering
	\includegraphics[height=5cm]{images/f000014}
\end{figure}
残差的自相关系数函数ACF图：
\begin{figure}[H]
	\caption{残差的自相关系数函数ACF图}
	\label{f000015}
	\centering
	\includegraphics[height=5cm]{images/f000015}
\end{figure}
残差的偏自相关系数函数PACF图：
\begin{figure}[H]
	\caption{残差的偏自相关系数函数PACF图}
	\label{f000016}
	\centering
	\includegraphics[height=5cm]{images/f000016}
\end{figure}
由ACF和PACF图可以看出，我们残差是比较典型的随机白噪声序列，由此可见我们拟合还是很好的。
\subsubsection{展望}
在理解了基本理论之后，我们将引入最终的ARIMA模型，并用ARIMA模型来拟合真实上证综指收盘价时间序列，并用我们的拟合模型来预测最后5日的收盘价，在这个实际例子中，看我们模型的表现如何。
\subsection{ARIMA模型}
\subsubsection{背景}
我们不仅可以对当前时间点数值对之前时间点数值进行建模，我们也可以对前面时间点随机噪声对当前时间点的影响进行建模，同时由于原始信号可能非常不平稳，但是我们求出其差值序列后，可能就变为平稳序列了，这就是ARIMA模型要解决的问题。为了讨论ARIMA模型，我们首先介绍差分的概念：
\begin{equation}
\begin{aligned}
\{ x_1,x_2,...,x_N \} \\
\{d_1^{1},d_2^{1},...,d_{N-1}^{1}\}=\{x_2-x_1,x_3-x_2,...,x_{N}-x_{N-1}\} \\
\{d_1^{2},d_2^{2},...,d_{N-1}^{2}\}=\{d_2^{1}-d_1^{1},d_3^{1}-d_2^{1},...,d_{N-1}^{1}-d_{N-1}^{1}\}
\end{aligned}
\label{e000030}
\end{equation}
上式中分别为原始时序信号，然后是一阶差分和二阶差分。
\subsubsection{模型选择标准}
\paragraph{BIC定义}
我们已经介绍过一个模型选择标准AIC（Akaike Information Criterion），其会惩罚参数多的模型，因为这些模型容易产生过拟合（Overfitting）。接下来我们要介绍另一个模型选择参数BIC（Bayes Information Criterion），与AIC相比，其会更倾向于惩罚参数多的模型，同样是值越小越好，BIC定义如下所示：
\begin{equation}
BIC=-2\log (L) + k \log N
\label{e000031}
\end{equation}
其中L为似然函数的最大值，k为模型的参数，N为数据点个数。
\paragraph{Ljung-Box检测}
我们的缺省假设$H_{0}$为：对于一个拟合的时序信号，对所有滞后时点lags，都是独立同分布（i.i.d）的，即不存在相关性。\newline
备择假设$H_{a}$为：这些信号不是独立同分布（i.i.d）的，具有相关性。\newline
我们定义统计量Q：
\begin{equation}
Q=n(n+2)\sum_{k=1}^{h} \frac{\hat{\rho}_{k}^{2}}{n-k}
\label{e000032}
\end{equation}
式\ref{e000032}中$n$为时间序列长度，$h$为最大滞后期数，$\rho _{k}$第$k$自相关系数。Ljung-Box检测原理比较复杂，但是在python语言中，经过运算可以求出Q值，以及大于Q值的概率，实际上我们看1$\sim$12滞后期的Q值和大于Q值的概率，如果该概率小于显著水平如0.05时，就拒绝缺省假设（不存在相关性），选择备择假设，否则反之。
\subsubsection{定义}
同时考虑之前时间点的信号和噪声值，我们就可以得到如下ARMA模型：
\begin{equation}
x_{t}=\alpha _{1}x_{t-1} + \alpha _{2}x_{t-2} + ... + \alpha _{p}x_{t-p} + w_{t} + \beta _1w_{t-1} + \beta _2w_{t-2}+...+ + \beta _{q}w_{t-q}
\label{e000033}
\end{equation}
如果我们对欲研究的信号求出一阶或二阶差分，然后再利用式\ref{e000033}的模型，就是ARIMA模型了。其中$\{ w_{t} \}$为白噪声，其均值为0，方差为$\sigma ^{2}$。\newline
其特性方程可以表示为：
\begin{equation}
\theta _{p}(B)x_{t}=\phi _{q}(B)w_{t}
\label{e000034}
\end{equation}
由上面的讨论可以看出，AR(p)和MA(q)都是ARIMA模型的特殊情况，在同样精度的条件下，ARIMA模型所需参数最小。
\subsubsection{数据仿真}
在理解了ARIMA模型定义之后，我们来模拟一下ARIMA过程。假设我们要模拟的ARIMA模型为：
\begin{equation}
\begin{aligned}
x_{t}=\alpha _{1}x_{t-1} + \alpha _{2}x_{t-2} + w_{t} + \beta _1w_{t-1} + \beta _2w_{t-2} \\
=1.2 \times x_{t-1} - 0.7 \times x_{t-2} + w_{t} - 0.06 \times w_{t-1} - 0.02 \times w_{t-2}
\end{aligned}
\label{e000035}
\end{equation}
生成模拟数据并利用ARIMA拟合的程序如下所示：
\lstset{language=PYTHON, caption={AR数据模拟和拟合示例}, label={c000005}}
\begin{lstlisting}
    def simulate_arima_p_d_q(self):
        print('模拟ARIMA(p,d,q)过程')
        np.random.seed(8)
        alpha1 = 1.2
        alpha2 = -0.7
        beta1 = -0.06
        beta2 = -0.02
        w = np.random.standard_normal(size=1000)
        x = w
        for t in range(2, len(w)):
            x[t] = alpha1 * x[t-1] + alpha2*x[t-2] + w[t] + beta1 * w[t-1] + beta2*w[t-2]
        plt.plot(x, c='b')
        plt.title('ARIMA(p, d, q) Figure')
        plt.show()
        # 查看ACF
        acfs = stattools.acf(x)
        print('ARIMA(q,d,q) ACFS:\r\n{0}'.format(acfs))
        tsaplots.plot_acf(x, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) ACF')
        plt.show()
        # ARIMA拟合
        min_ABQIC = sys.float_info.max
        arima_model = None
        break_loop = False
        '''
        for p in range(0, 5):
            if break_loop:
                break
            for q in range(0, 5):
                print('try {0}, d, {1}...'.format(p, q))
                try:
                    arima_p_d_q = ARIMA(x, order=(p, 0, q)).fit(disp=False)
                    print('..... fit ok')
                    if arima_p_d_q.aic < min_ABQIC:
                        print('..... record good model')
                        min_ABQIC = arima_p_d_q.aic
                        arima_model = arima_p_d_q
                        #if 1==p and 1==q:
                        #    break_loop = True
                except Exception as ex:
                    print('.....!!!!!! Exception')
        print('ARIMA: p={0} **** {1}; q={2}***{3}; {4} - {5} - {6}'. \
                    format(arima_model.k_ar, arima_model.arparams, 
                    arima_model.k_ma, arima_model.maparams, 
                    arima_model.aic, arima_model.bic, 
                    arima_model.hqic)
        )
        '''
        arima_model = ARIMA(x, order=(2, 0, 2)).fit(disp=False)
        print('God_View:ARIMA: p={0} **** {1}; q={2}***{3}; {4} - {5} - {6}'. \
                    format(arima_model.k_ar, arima_model.arparams, 
                    arima_model.k_ma, arima_model.maparams, 
                    arima_model.aic, arima_model.bic, 
                    arima_model.hqic)
        )
        resid = arima_model.resid
        # 绘制ACF
        acfs = stattools.acf(resid)
        print(acfs)
        tsaplots.plot_acf(resid, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) ACF figure')
        plt.show()
        pacfs = stattools.pacf(resid)
        print(pacfs)
        tsaplots.plot_pacf(resid, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) PACF figure')
        plt.show()
\end{lstlisting}
生成的时序信号x为：
\begin{figure}[H]
	\caption{原始模拟信号图}
	\label{f000017}
	\centering
	\includegraphics[height=5cm]{images/f000017}
\end{figure}
该信号的自相关系数函数ACF图为：
\begin{figure}[H]
	\caption{原始模拟信号ACF图}
	\label{f000018}
	\centering
	\includegraphics[height=5cm]{images/f000018}
\end{figure}
由图中可以看出，该信号具有非常强的自相关性。\newline
接着我们用ARIMA模型来模拟该信号，上面程序注释部分为求最佳ARIMA模型的p和q参数，以AIC作为模型选择标准，因为我们知道模型为ARIMA(2,0,2)，所以我们同时也用ARIMA(2,0,2)来进行拟合，程序运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000019}
	\centering
	\includegraphics[height=5cm]{images/f000019}
\end{figure}
接着我们求出残差序列，残差序列自相关系数函数ACF图如下所示：
\begin{figure}[H]
	\caption{残差自相关系数函数ACF图}
	\label{f000020}
	\centering
	\includegraphics[height=5cm]{images/f000020}
\end{figure}
残差序列偏自相关系数函数图PACF如下所示：
\begin{figure}[H]
	\caption{残差偏自相关系数函数ACF图}
	\label{f000021}
	\centering
	\includegraphics[height=5cm]{images/f000021}
\end{figure}
由图中可以看出，残差序列基本上是白噪声信号。
\subsubsection{金融数据拟合及预测}
接下来我们用ARIMA模型，来拟合上证综指收盘价，我们利用除最后3天的数据来得出ARIMA模型，然后利用拟合出的ARIMA模型来预测后3天的收盘价，来看我们模型的性能。根据经验，对于股票的收盘数据来说，采用取对数后再求1阶差分的形式，可以取得更好的效果，因此我们会先对数据进行预处理，然后再来用ARIMA模型来拟合数据。\newline
程序如下所示：
\lstset{language=PYTHON, caption={ARIMA数据拟合上证综指收盘价}, label={c000007}}
\begin{lstlisting}
    def arima_demo(self):
        register_matplotlib_converters()
        data = pd.read_csv(self.data_file, sep='\t', index_col='Trddt')
        sh_index = data[data.Indexcd==1]
        sh_index.index = pd.to_datetime(sh_index.index)
        raw_data = sh_index.Clsindex
        train_data = raw_data[:-3]
        close_price = np.log(train_data)
        plt.plot(close_price)
        plt.show()
        print(train_data.head(n=3))
        # ARIMA拟合
        min_ABQIC = sys.float_info.max
        arima_model = None
        for p in range(0, 5):
            for q in range(0, 5):
                print('try {0}, d, {1}...'.format(p, q))
                try:
                    arima_p_d_q = ARIMA(close_price, order=(p, 1, q)).fit(disp=False)
                    print('..... fit ok')
                    if arima_p_d_q.aic < min_ABQIC:
                        print('..... record good model')
                        min_ABQIC = arima_p_d_q.aic
                        arima_model = arima_p_d_q
                except Exception as ex:
                    print('.....!!!!!! {0}'.format(ex))
        print('ARIMA: p={0} **** {1}; q={2}***{3}; {4} - {5} - {6}'. \
                    format(arima_model.k_ar, arima_model.arparams, 
                    arima_model.k_ma, arima_model.maparams, 
                    arima_model.aic, arima_model.bic, 
                    arima_model.hqic)
        )
        resid = arima_model.resid
        # 绘制ACF
        acfs = stattools.acf(resid)
        print(acfs)
        tsaplots.plot_acf(resid, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) ACF figure')
        plt.show()
        pacfs = stattools.pacf(resid)
        print(pacfs)
        tsaplots.plot_pacf(resid, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) PACF figure')
        plt.show()
        # ADF检验
        resid_adf = unitroot.ADF(resid)
        print('stat={0:0.4f} vs 1%_cv={1:0.4f}'.format(resid_adf.stat, resid_adf.critical_values['1%']))
        if resid_adf.stat < resid_adf.critical_values['1%']:
            print('resid为稳定时间序列 ^_^')
        else:
            print('resid为非稳定时间序列！！！！！')
        # Ljung-Box检验
        resid_ljung_box = stattools.q_stat(stattools.acf(resid)[1:12], len(resid))
        resid_lbv = resid_ljung_box[1][-1]
        print('resid_ljung_box_value={0}'.format(resid_lbv))
        # 0.05为显著性水平
        if resid_lbv < 0.05:
            print('resid为平稳时间序列 ^_^')
        else:
            print('resid为非平稳时间序列！！！！！！！')
        # 预测
        y = arima_model.forecast(3)[0] #(len(train_data), len(raw_data), dynamic=True)
        print('预测值：{0}'.format(np.exp(y)))
        print('row_data:{0}'.format(raw_data))
        print('train_data:{0}'.format(train_data))
\end{lstlisting}
我们首先绘制出上证综指收盘价曲线：
\begin{figure}[H]
	\caption{上证综指收盘价}
	\label{f000023}
	\centering
	\includegraphics[height=5cm]{images/f000023}
\end{figure}
接着我们对该数据经过对数差分后，利用ARIMA来进行拟合，得到拟合模型为：
\begin{figure}[H]
	\caption{拟合后的ARIMA模型}
	\label{f000024}
	\centering
	\includegraphics[height=2cm]{images/f000024}
\end{figure}
残差序列的自相关系数函数ACF图为：
\begin{figure}[H]
	\caption{残差序列的自相关系数函数ACF图}
	\label{f000025}
	\centering
	\includegraphics[height=5cm]{images/f000025}
\end{figure}
残差序列的偏自相关系数函数PACF图为：
\begin{figure}[H]
	\caption{残差序列的偏自相关系数函数PACF图}
	\label{f000026}
	\centering
	\includegraphics[height=5cm]{images/f000026}
\end{figure}
进行ADF检验的结果为：
\begin{figure}[H]
	\caption{ADF检验的结果}
	\label{f000027}
	\centering
	\includegraphics[height=1cm]{images/f000027}
\end{figure}
进行Ljung-Box检验结果为：
\begin{figure}[H]
	\caption{Ljung-Box检验结果}
	\label{f000028}
	\centering
	\includegraphics[height=1cm]{images/f000028}
\end{figure}
最后我们拿我们的模型进行预测，后三天的预测结果为：
\begin{figure}[H]
	\caption{ARIMA模型预测后三天结果}
	\label{f000029}
	\centering
	\includegraphics[height=0.6cm]{images/f000029}
\end{figure}
实际值为：
\begin{figure}[H]
	\caption{实际收盘价}
	\label{f000030}
	\centering
	\includegraphics[height=2cm]{images/f000030}
\end{figure}
我们看到，我们的模型基本预测出了后三天的连涨行情，只不过上涨的幅度有一些小。

\maketitle\begin{center}
\Large \textbf{第3章 GARCH模型}
\end{center}
\begin{abstract}
在本章中我们将首先讲述条件异方差模型GARCH（Generalized AutoRegressive Conditional Heteroskedastic），
并将GARCH模型用于实际金融时间序列数据拟合。aqt002.py
\end{abstract}
\section{GARCH模型}
我们之前讨论的时序信号，都是假定其为平稳的。但是有很多时序信号，如某些商品的需求或价格，会随着季节的变化而发生变化，股票的价格为出现长时间的上涨或下跌趋势，在这些情况下，使用ARIMA模型的效果就不太好。对于我们要研究的股票数据，由于市场上很多交易是由大机构的算法来进行交易的，当出现价格明显示上涨或下跌时，会自动触发这些算法进行交易，从而放大了这种上涨或下跌趋势。这种情况我们称之为异方差，研究这种现象的方法我们称之为通用自回归条件异方差GARCH（Generalized AutoRegression Conditional Heteroskedasticity）模型。
\subsection{定义}
\subsubsection{ARCH模型}
我们先来看较为简单的自回归条件异方差ARCH模型，我们假设时序信号如下所示：
\begin{equation}
\epsilon _{t} = \sigma _{t} w_{t}
\label{e000050}
\end{equation}
其中$w_{t}$为白噪声序列，$\sigma _{t}$的定义如下所示：
\begin{equation}
\sigma _{t}^{2} = \alpha _{0} + \alpha _{1} \epsilon _{t-1}^{2}
\label{e000051}
\end{equation}
这个模型我们称之为ARCH(1)模型。我们以这个简单的模型为例，来说明ARCH(1)模型是对时序信号方差的变化进行建模。
我们首先来看时间序列$\{ \epsilon _{t} \}$的均值：
\begin{equation}
E(\epsilon _{t}) = E(\sigma _t w_{t}) = E(\sigma _{t})E(w_{t})=0
\label{e000052}
\end{equation}
我们再来看时间序列$\{ \epsilon _{t} \}$的方差：
\begin{equation}
\begin{aligned}
Var(\epsilon _{t}) = E\big( \epsilon _{t} - E(\epsilon _{t}) \big)^{2} =E\big( \epsilon _{t}^{2} - 2\epsilon _{t}E(\epsilon _{t}) + (E(\epsilon _{t}))^{2} \big) \\
=E(\epsilon _{t}^{2})-2E(\epsilon _{t})E(\epsilon _{t})+(E(\epsilon _{t}))^{2}=E(\epsilon _{t}^{2})-(E(\epsilon _{t}))^{2} \\
=E(\epsilon _{t}^{2})=E(\sigma _{t}^{2}w_{t}^{2})=E(\sigma _{t}^{2})E(w_{t}^{2})=E(\alpha _{0} + \alpha _{1}\epsilon _{t-1}^{2}) \\
=\aleph _{0} + \alpha _{1}E(\epsilon _{t-1}^{2})=\alpha _{0} + \alpha _{1}Var(\epsilon _{t-1})
\end{aligned}
\label{e000053}
\end{equation}
在上面的公式推导中，我们用到了$\{ w_{t} \}$为白噪声信号，其均值为0，方差为1。\newline
了解了基本ARCH模型之后，我们可以将ARCH(1)模型扩展到ARCH(p)模型，这里我们就不再展开了，将在下一节GARCH模型中进行详细介绍。
\subsubsection{GARCH模型}
对于时间序列信号$\{ \epsilon _{t} \}$其表达式为：
\begin{equation}
\epsilon _{t} = \sigma _{t} w_{t}
\label{e000054}
\end{equation}
其中$\{ w_{t} \}$为白噪声信号，其均值为0方差为1。其$\sigma _{t}^{2}$的定义为：
\begin{equation}
\sigma _{t}^{2} = \alpha _{0} + \sum_{i=1}^{p} \alpha _{i} \epsilon _{t-i}^{2} + \sum_{j=1}^{q} \beta _{j} \sigma _{t-j}^{2}
\label{e000055}
\end{equation}
其中$\alpha _{0}$、$\alpha _{i}$、$\beta _{j}$为参数。
\subsection{数据模拟}
为了对问题进行简化，我们在这里只模拟GARCH(1,1)模型，具体欲模拟的时间序列信号如下所示，在arch包的GARCH模型中，我们研究的信号为$r_{t}$，并且多出一个参数$\mu$：
\begin{equation}
\begin{aligned}
r_{t} = \epsilon _{t} + \mu \\
\epsilon _{t} = \sigma _{t}w_{t} \\
\sigma _{t}^{2} = \omega + \alpha _{1} \epsilon _{t-1}^{2} + \beta _{1} \sigma _{t-1}^{2}=0.2 + 0.5\epsilon _{t-1}^{2} + 0.3\sigma _{t-1}^{2}
\end{aligned}
\label{e000056}
\end{equation}
其程序如下所示：
\lstset{language=PYTHON, caption={GARCH拟合模拟数据}, label={c000008}}
\begin{lstlisting}
import sys
import math
import numpy as np
import pandas as pd
from pandas.plotting import register_matplotlib_converters
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.font_manager import FontProperties
from statsmodels.tsa import stattools
from statsmodels.graphics import tsaplots
from statsmodels.tsa.arima_model import ARIMA
import arch.unitroot as unitroot
import arch as arch

class Aqt002(object):
    def __init__(self):
        self.name = 'Aqt001'
        # 数据文件格式：编号 日期 星期几 开盘价 最高价 
        # 最低价 收益价 收益
        # Indexcd	Trddt	Daywk	Opnindex	Hiindex	
        # Loindex	Clsindex	Retindex
        self.data_file = 'data/pqb/aqt002_001.txt'
        
    def startup(self):
        print('GARCH模型...')
        np.random.seed(1)
        alpha0 = 0.2
        alpha1 = 0.5
        beta1 = 0.3
        samples = 10000 # 样本数量
        w = np.random.standard_normal(size=samples)
        epsilon = np.zeros((samples,), dtype=float)
        sigma = np.zeros((samples,), dtype=float)
        for i in range(2, samples):
            sigma_2 = alpha0 + alpha1 * math.pow(epsilon[i-1], 2) + \
                        beta1 * math.pow(sigma[i-1], 2)
            sigma[i] = math.sqrt(sigma_2)
            epsilon[i] = sigma[i]*w[i]
        plt.title('epsilon signal')
        plt.plot(epsilon)
        plt.show()
        # 绘制epsilonACFS
        acfs = stattools.acf(epsilon)
        tsaplots.plot_acf(epsilon, use_vlines=True, lags=30)
        plt.title('epsilon ACF')
        plt.show()
        # 绘制epsilon pow2 ACF
        acfs2 = stattools.acf(np.power(epsilon, 2))
        tsaplots.plot_acf(np.power(epsilon, 2), use_vlines=True, lags=30)
        plt.title('pow(epsilon,2) ACF')
        plt.show()
        # GARCH拟合
        am = arch.arch_model(epsilon, x=None, mean='Constant', 
                    lags=0, vol='Garch', p=1, o=0, q=1, 
                    power=2.0, dist='Normal', hold_back=None)
        model = am.fit(update_freq=0)
        # GARCH(1,1)参数
        print('############ GARCH(1,1)参数  ###################')
        print('model_type:{0}'.format(type(model)))
        print('mu={0:0.2f}; a0={1:0.2f}; a1={2:0.2f}; b1={3:0.2f}' \
                    .format(model.params['mu'], model.params['omega'], 
                    model.params['alpha[1]'], model.params['beta[1]']   ))
        print('###############################')
        #print(model.summary())
        # 残差信号
        plt.title('GARCH(1,1) resid')
        plt.plot(model.resid)
        plt.show()
        # 残差ACF
        resid_acf = stattools.acf(model.resid)
        tsaplots.plot_acf(model.resid, use_vlines=True, lags=30)
        plt.title('GARCH(1,1) resid ACF')
        plt.show()
        # ADF检验
        resid_adf = unitroot.ADF(model.resid)
        print('stat={0:0.4f} vs 1%_cv={1:0.4f}'.format( \
                    resid_adf.stat, resid_adf.critical_values['1%']))
        if resid_adf.stat < resid_adf.critical_values['1%']:
            print('resid为稳定时间序列 ^_^')
        else:
            print('resid为非稳定时间序列！！！！！')
        # Ljung-Box检验
        resid_ljung_box = stattools.q_stat(stattools.acf( \
                    model.resid)[1:12], len(model.resid))
        resid_lbv = resid_ljung_box[1][-1]
        print('resid_ljung_box_value={0}'.format(resid_lbv))
        # 0.05为显著性水平
        if resid_lbv < 0.05:
            print('resid为平稳时间序列 ^_^')
        else:
            print('resid为非平稳时间序列！！！！！！！')
        # 预测
        y = model.forecast(horizon=3)
        print('########### 预测值  ###############')
        print('len={0}; p1={1:0.3f}; p2={2:0.3f}; p3={3:0.3f}'. \
                    format(len(y.mean.iloc[-1]), y.mean.iloc[-1][0], 
                    y.mean.iloc[-1][1], y.mean.iloc[-1][2]))
        print('##########################')
\end{lstlisting}
我们欲拟合的时间序列信号为：
\begin{figure}[H]
	\caption{拟拟合的时间序列}
	\label{f000031}
	\centering
	\includegraphics[height=2cm]{images/f000031}
\end{figure}
该时间序列的自相关系数函数ACF图：
\begin{figure}[H]
	\caption{epsilon的自相关系数函数ACF图}
	\label{f000032}
	\centering
	\includegraphics[height=2cm]{images/f000032}
\end{figure}
由上图可以看出，其基本是一个平稳时间序列。我们取其平方，其自相关系数函数ACF图如下所示：
\begin{figure}[H]
	\caption{pow(epsilon,2)的自相关系数函数ACF图}
	\label{f000033}
	\centering
	\includegraphics[height=2cm]{images/f000033}
\end{figure}
由上图可以看出，将其平方后，其就是不平稳的时间序列了。GARCH模型就是来处理这种情况的。\newline
我们采用GARCH进行拟合后，得到的残差信号为：
\begin{figure}[H]
	\caption{GARCH(1,1)残差序列}
	\label{f000034}
	\centering
	\includegraphics[height=2cm]{images/f000034}
\end{figure}
残差信号的自相关系数函数ACF图为：
\begin{figure}[H]
	\caption{GARCH(1,1)残差序列自相关系数函数ACF图}
	\label{f000035}
	\centering
	\includegraphics[height=2cm]{images/f000035}
\end{figure}
程序的运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000036}
	\centering
	\includegraphics[height=2cm]{images/f000036}
\end{figure}
由上图可知，我们对GARCH(1,1)模型的参数预测还是相当准确的，说明我们方法是正确的。
\subsection{金融数据拟合}
下面我们以上证综指的收盘价为例，来讨论GARCH拟合预测后三天股价问题。对于收盘价这样的信号，我们仍然采用对数一阶差分形式来作为建模的时间序列，我们用GARCH(3,2)来进行拟合，程序如下所示：
\lstset{language=PYTHON, caption={GARCH拟合并预测上证综指收盘价}, label={c000009}}
\begin{lstlisting}
    def garch_finance_demo(self):
        print('拟合上证综指收盘价...')
        register_matplotlib_converters()
        data = pd.read_csv(self.data_file, sep='\t', index_col='Trddt')
        sh_index = data[data.Indexcd==1]
        sh_index.index = pd.to_datetime(sh_index.index)
        sh_return = sh_index.Retindex
        # raw_data = sh_index.Retindex
        raw_data = sh_index.Clsindex
        train_data = raw_data[:-3]
        dcp = np.log(train_data).diff(1)[1:] 
        plt.plot(dcp)
        plt.show()
        # GARCH拟合
        am = arch.arch_model(dcp, x=None, mean='Constant', 
                    lags=0, vol='Garch', p=3, o=0, q=2, 
                    power=2.0, dist='Normal', hold_back=None)
        model = am.fit(update_freq=0)
        # GARCH(1,1)参数
        print('############ GARCH(1,1)参数  ###################')
        '''
        print('mu={0:0.2f}; a0={1:0.2f}; a1={2:0.2f}; a2={3:0.2f}, b1={4:0.2f}, b2={5:0.2f}' \
                    .format(model.params['mu'], model.params['omega'], 
                    model.params['alpha[1]'], model.params['alpha[2]'], model.params['beta[1]'], model.params['beta[2]']   ))
        '''
        print('###############################')
        resid = model.resid
        # 绘制ACF
        acfs = stattools.acf(resid)
        print(acfs)
        tsaplots.plot_acf(resid, use_vlines=True, lags=30)
        plt.title('GARCH(p,q) ACF figure')
        plt.show()
        '''
        pacfs = stattools.pacf(resid)
        print(pacfs)
        tsaplots.plot_pacf(resid, use_vlines=True, lags=30)
        plt.title('ARIMA(p,d,q) PACF figure')
        plt.show()
        '''
        # ADF检验
        resid_adf = unitroot.ADF(resid)
        print('stat={0:0.4f} vs 1%_cv={1:0.4f}'.format(resid_adf.stat, resid_adf.critical_values['1%']))
        if resid_adf.stat < resid_adf.critical_values['1%']:
            print('resid为稳定时间序列 ^_^')
        else:
            print('resid为非稳定时间序列！！！！！')
        # Ljung-Box检验
        resid_ljung_box = stattools.q_stat(stattools.acf(resid)[1:12], len(resid))
        resid_lbv = resid_ljung_box[1][-1]
        print('resid_ljung_box_value={0}'.format(resid_lbv))
        # 0.05为显著性水平
        if resid_lbv < 0.05:
            print('resid为平稳时间序列 ^_^')
        else:
            print('resid为非平稳时间序列！！！！！！！')
        # 预测
        frst = model.forecast(horizon=3)
        y = frst.mean.iloc[-1]
        print('预测值：{0}'.format(y))
        p1 = math.exp(math.log(train_data[-1]) + y[0])
        p2 = math.exp(math.log(p1) + y[1])
        p3 = math.exp(math.log(p2) + y[2])
        print('        预测值    实际值  (3957.534)')
        print('第一天：{0} vs 4034.310'.format(p1))
        print('第二天：{0} vs 4121.715'.format(p2))
        print('第三天：{0} vs 4135.565'.format(p3))
\end{lstlisting}
我们要建模的上证综指收盘价对数差分信号如下所示：
\begin{figure}[H]
	\caption{上证综指收盘价对数差分信号}
	\label{f000037}
	\centering
	\includegraphics[height=2cm]{images/f000037}
\end{figure}
经过GARCH(3,2)拟合后的残差信号：
\begin{figure}[H]
	\caption{上证综指收盘价对数差分信号}
	\label{f000038}
	\centering
	\includegraphics[height=2cm]{images/f000038}
\end{figure}
由图可见，其基本是一个平稳时间序列，可以用来进行预测。但是我们ADF检验表明其是平稳时间序列，但是Ljung-Box检验表明其不是时间平稳时间序列，因此我们还需要仔细分析其中的原因。程序运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000039}
	\centering
	\includegraphics[height=2cm]{images/f000039}
\end{figure}
由上图可以看出，预测结果也基本捕捉到了后三天连涨趋势，只是涨幅估计偏低，这证明我们采用GARCH(p,q)模型来预测是可行的。






python的ARIMA：   https://www.colabug.com/3933896.html
Ln125 Advanced Algorithmic Trading
























\maketitle\begin{center}
\Large \textbf{第4章 协整模型}
\end{center}
\begin{abstract}
在本章中我们将首先讲述交易对的概念，并讲述如何利用交易对的均值回归特性，通过对交易对的多空操作，实现稳定的盈利。在本章中，我们主要讲解交易对的数学原理，怎样确定对冲比例。对于怎样利用交易对进行统计套利策略研发，将在后续章节中介绍。aqt003.py
\end{abstract}
\section{协整模型}
本章讲述的内容是统计套利策略，这是一种市场中性策略，无论是市场是涨是跌，均有可能盈利。将统计套利用到极致的例子，应该属于上世纪90年代的LTCM基金。LTCM基金成立于1994年，成立时基金规模为12.5亿美金，但是到1997年，基金规模就达到了48亿美金，是当时世界上四大基金之一。LTCM基金的创始人是金牌交易员，合伙人是顶级统计学家，他们发现德国国债和意大利国债有一个稳定的比例关系，大概率波动的机率会非常小，因此当德国国债上涨时，德国国债与意大利国债之比将增大，大幅度偏离均值，他们就卖出德国国债，买入意大利国债，一段时间之后，德国国债会下跌，德国国债和意大利国债之比就会回归到均值，此时他们卖出之前买入的意大利国债，重新买入之前卖出的德国国债，这样他们持有德国国债和意大利国债没有发生变化，但是却赚到了这次波动差价所产生的利润。利用这种方式，LTCM基金获得了巨大的成功。然而LTCM基金的神话终结于1997年，主要有以下几个原因：首先LTCM认为德国国债和意大利国债之比符合正态分布，但是虽然自然界大部分复杂的现象都是正态分布，但是人类社会现象，却不一定是正态分布，黑天鹅事件也许是长态，在1997年，东南亚发生了金融危机，俄罗斯发生了国债违约，正是这两个黑天鹅事件，使德国国债与意大利国债之比不再符合正态分布，而LTCM基金由于对这些事件缺乏预见性，而遭受了巨大的损失；同时，在LTCM基金破产之后，人们看LTCM基金的财务数据发现，其资金杠杆高达数万倍，因此一次失误的决策，就足以使整个公司破产。由这个实例我们可以看出，基于交易对均值回归的统计回归策略，具有巨大的盈利潜力，同时我们也应看到，杠杆是魔鬼，任何策略中最重要的都是资金和仓位管理。\newline
交易对不仅在传统金融市场，如股市、期货、外汇、债市上存在，在新兴的加密货币市场，也是一种非常重要的策略，前一两年兴起的比特币搬砖模式，就是交易对策略在加密货市场的应用。
\subsection{数据模拟}
\subsubsection{协整模型构建}
根据\cite{r000002}的内容，我们可以通过模拟数据来加深我们对基本概念的理解。假设$\{ w_{t} \}$为白噪声，在此基础上定义随机游走信号：
\begin{equation}
z_{t} = z_{t-1} + w_{t}
\label{e000058}
\end{equation}
在此基础上我们定义两个非平稳的时间序列信号：
\begin{equation}
x_{t} = pz_{t} + w_{t} = 0.3z_{t} + w_{t}
\label{e000059}
\end{equation}
\begin{equation}
y_{t} = qz_{t} + w_{t} = 0.6z_{t} + w_{t}
\label{e000060}
\end{equation}
如果我们将$\{ x_{t} \}$和$\{ y_{t} \}$进行线性组合：
\begin{equation}
ax_{t} + by_{t} = (ap+bq)z_{t} + w_{t} = (0.3a+0.6b)z_{t} + w_{t}
\label{e000061}
\end{equation}
如果$0.3a+0.6b=0$的话，那么$\{ x_{t} \}$和$\{ y_{t} \}$的这个线性组合就只剩下白噪声信号，因此其是
平稳时间序列信号，因此当$a=2, b=-1$时，这个序列就是平稳时间序列信号。\newline
根据这一思想，程序如下所示：
\lstset{language=PYTHON, caption={线性组合形成平稳时间序列}, label={c000010}}
\begin{lstlisting}
    def simulate_demo(self):
        '''
        模拟数据生成
        '''
        # 生成白噪声信号
        samples = 1000
        w = np.random.standard_normal(size=samples)
        # 生成随机游走序列
        z = np.zeros((samples,))
        for t in range(1, samples):
            z[t] = z[t-1] + w[t]
        # 生成非平稳信号，即交易对x和y
        x = np.zeros((samples,))
        y = np.zeros((samples,))
        p = 0.3
        q = 0.6
        for t in range(samples):
            x[t] = p*z[t] + w[t]
            y[t] = q*z[t] + w[t]
        fig = plt.figure(figsize=(6, 6))
        w_plt = plt.subplot(2, 2, 1, title='White Noise: w')
        w_plt.plot(w)
        z_plt = plt.subplot(2, 2, 2, title='Random Walk: z')
        z_plt.plot(z)
        x_plt = plt.subplot(2, 2, 3, title='Non Stationary Signal: x')
        x_plt.plot(x)
        y_plt = plt.subplot(2, 2, 4, title='Non Stationary Signal: y')
        y_plt.plot(y)
        fig.tight_layout()
        plt.show()
        # 生成协整信号
        a = 2
        b = -1
        c = a * x + b * y
        plt.plot(c)
        plt.title('Cointegration Model')
        plt.show()
        # 采用ADF检验 
        resid_adf = unitroot.ADF(c)
        print('stat={0:0.4f} vs 1%_cv={1:0.4f}'.format( \
                    resid_adf.stat, resid_adf.critical_values['1%']))
        if resid_adf.stat < resid_adf.critical_values['1%']:
            print('resid为稳定时间序列 ^_^')
        else:
            print('resid为非稳定时间序列！！！！！')
\end{lstlisting}
我们首先绘制出白噪声、随机游走和x及y信号：
\begin{figure}[H]
	\caption{研究序列}
	\label{f000042}
	\centering
	\includegraphics[height=5cm]{images/f000042}
\end{figure}
接着我们绘制出x和y的线性组合：
\begin{figure}[H]
	\caption{x和y的线性组合}
	\label{f000043}
	\centering
	\includegraphics[height=5cm]{images/f000043}
\end{figure}
我们利用ADF检验其稳写性：
\begin{figure}[H]
	\caption{ADF检验}
	\label{f000044}
	\centering
	\includegraphics[height=1cm]{images/f000044}
\end{figure}
由上面的ADF检验可以看出，x和y的线性组合与理论分析一致，是平稳时间序列。
\subsubsection{对冲比例确定}
在上面的例子中，我们验证了我们的假设，即对两个非平稳的时间序列进行线性组合，通过选择合适的系数，可以得到平稳时间序
列信号。现在的问题就变为怎样求出这些系数，使线性组合后的时间序列具有平稳性。在这一节中，我们将向大家演示采用线性
回归技术，来求出线性组合的系数。虽然线性回归算法非常简单，尤其是我们这里只有一维，就更简单了。但是这里我们将采用
Google在今年3月新推出的TensorFlow 2.0 alpha，采用高级API keras来完成这一过程。\newline
\paragraph{线性回归模型}
在讲解确定线性组合系数之前，我们先来讲解一下为达到这一目的所开发的基于TensorFlow 2.0的线性回归模型。代码如下所示：
\lstset{language=PYTHON, caption={基于TensorFlow 2.0的线性回归模型}, label={c000011}}
\begin{lstlisting}
    import numpy as np
    import matplotlib.pyplot as plt
    import tensorflow as tf
    
    class QciLinearRegression(object):
        def __init__(self, train_x=None, train_y=None, 
                    validate_x=None, validate_y=None, 
                    test_x=None, test_y=None):
            self.name = 'QciLinearRegression'
            self.loss = 'mean_squared_error'
            self.learning_rate = 0.01
            self.optimizer = tf.keras.optimizers.Adam(self.learning_rate)
            self.epoch = 50000
            if train_x:
                self.train_x = train_x
                self.train_y = train_y
                self.validate_x = validate_x
                self.validate_y = validate_y
                self.test_x = test_x
                self.test_y = test_y
            else:
                self.train_x, self.train_y, self.validate_x, \
                            self.validate_y, self.test_x, \
                            self.test_y = self.generate_dataset()
    
        def generate_dataset(self):
            train_x = np.array([-40, -10, 0, 8, 15, 22, 38, 20, 9, 13], dtype=float)
            train_y = np.array([-40, 14, 32, 46, 59, 72, 100, 68, 48.2, 55.4], dtype=float)
            validate_x = np.array([], dtype=float)
            validate_y = np.array([], dtype=float)
            test_x = np.array([], dtype=float)
            test_y = np.array([], dtype=float)
            return train_x, train_y, validate_x, validate_y, test_x, test_y
    
        def train(self):
            model = self.build_model()
            model.compile(loss=self.loss, optimizer=self.optimizer)
            class PrintDot(tf.keras.callbacks.Callback):
                def on_epoch_end(self, epoch, logs):
                    if epoch % 100 == 0: print('')
                    print('epoch:{0}...{1}!'.format(epoch, logs))
            early_stop = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=10)
            history = model.fit(self.train_x, self.train_y, 
                        epochs=self.epoch, validation_split = 0.1,  
                        verbose=False, callbacks=[early_stop, PrintDot()])
            plt.title('linear regression training process')
            plt.xlabel('epochs')
            plt.ylabel('error')
            plt.plot(history.history['loss'])
            plt.show()
            model.save('./work/aqt003_qiclr')
            weights = np.array(model.get_weights())
            print(weights)
    
        def build_model(self):
            layer1 = tf.keras.layers.Dense(units=1, input_shape=[1])
            model = tf.keras.Sequential([layer1])
            return model
    
        def predict(self, data):
            model = tf.keras.models.load_model('./work/aqt003_qiclr')
            rst = model.predict(data)
            return rst
    
    if '__main__' == __name__:
        lr = QciLinearRegression()
        lr.train()    
\end{lstlisting}
初始化函数的参数为训练样本集、验证样本集和测试样本集，缺省值为空，当不传递这些值时，我们采用类内定义的
generate\_dataset方法来为这些属性赋值。同时，在构造函数中设定了代价函数为最小平方误差函数，学习率为0.01，优化
算法为最常用的Adam，训练遍数为5万。\newline
在generate\_dataset函数中，我们输入特征为摄氏度的温度，而输出值为华氏度的温度，二者的关系为：
\begin{equation}
F = 1.8 \times C + 32
\label{e000062}
\end{equation}
我们任务就是学出1.8和32这两个参数。\newline
外部程序通过调用train方法作为入口，程序首先调用build\_model方法生成模型，我们的这个网络由两层组成，第1层为输入层
只有一个节点，第2层为输出层，其也只有一个节点，这个网络的参数为：第1层节点到第2层节点的连接权值和第2层神经元的偏置
值。创建完模型之后，我们通过model.compile来设置模型的代价函数和优化算法；为了提高模型的泛化能力避免overfitting，
我们采用early stopping算法，当验证集上的精度在10个循环中没有明显改进时，停止训练过程（在后面的日志中，我们可以看到
虽然我们定义训练5万次，但是实际训练不到1万次就停止了）。接着我们定义一个临时类，因为神经网络训练
通常会很耗时，我们用这个函数打印当前进度情况。接着我们调用model.fit来开始实际训练过程，在后台日志中我们可以看到，误差
会逐渐减少，如图所示：
\begin{figure}[H]
	\caption{程序运行日志}
	\label{f000045}
	\centering
	\includegraphics[height=3cm]{images/f000045}
\end{figure}
我们可以看到最后一列的验证集上的误差在10次没有明显变化时，由于early stopping算法，训练过程就自动结束了。接下来我们
可以绘制出误差随训练时间的变化过程，如下所示：
\begin{figure}[H]
	\caption{误差变化曲线}
	\label{f000046}
	\centering
	\includegraphics[height=1cm]{images/f000046}
\end{figure}
最终学到的参数值为：
\begin{figure}[H]
	\caption{误差变化曲线}
	\label{f000047}
	\centering
	\includegraphics[height=1cm]{images/f000047}
\end{figure}
我们看到其与实际值就非常接近了，证明我们线性回归模型是正确的。虽然在我们协整模型中用不到，但是我们还是介绍一下当网络训
练完成之后，下一步就给出数据，让其给我们算出真实的结果，这在predict方法中实现。在predict方法中，首先从模型文件中
恢复出网络结构，然后运行模型的predict方法生成并返回预测值，调用代码如下所示：
\lstset{language=PYTHON, caption={利用线性回归模型进行预测}, label={c000012}}
\begin{lstlisting}
    data = np.array([[100.0]], dtype=float)
    rst = qcilr.predict(data)
    print(rst)
\end{lstlisting}
运行结果如下所示：
\begin{figure}[H]
	\caption{预测值}
	\label{f000048}
	\centering
	\includegraphics[height=1cm]{images/f000048}
\end{figure}
\paragraph{对冲比例确定}
在有了线性回归模型之后，下面我们就用线性回归模型来确定对冲比例。程序如下所示：
\lstset{language=PYTHON, caption={线性回归模型确定对冲比例}, label={c000013}}
\begin{lstlisting}
    def qcilr_demo(self):
        # 生成白噪声信号
        samples = 1000
        w = np.random.standard_normal(size=samples)
        # 生成随机游走序列
        z = np.zeros((samples,))
        for t in range(1, samples):
            z[t] = z[t-1] + w[t]
        # 生成非平稳信号，即交易对x和y
        x = np.zeros((samples,))
        y = np.zeros((samples,))
        p = 0.3
        q = 0.6
        for t in range(samples):
            x[t] = p*z[t] + w[t]
            y[t] = q*z[t] + w[t]
        fig = plt.figure(figsize=(6, 6))
        w_plt = plt.subplot(2, 2, 1, title='White Noise: w')
        w_plt.plot(w)
        z_plt = plt.subplot(2, 2, 2, title='Random Walk: z')
        z_plt.plot(z)
        x_plt = plt.subplot(2, 2, 3, title='Non Stationary Signal: x')
        x_plt.plot(x)
        y_plt = plt.subplot(2, 2, 4, title='Non Stationary Signal: y')
        y_plt.plot(y)
        fig.tight_layout()
        plt.show()
        # 以x作为自变量
        w1, x_y_p = self.do_linear_regression(x, y)
        # 将y作为自变量
        w2, y_x_p = self.do_linear_regression(y, x)
        print('xToy={0}({1}) vs yTox={2}({3})'.format(x_y_p, w1[0][0], y_x_p, w2[0][0]))
        if x_y_p < y_x_p:
            print('######## x  为自变量')
            c = w1[0][0] * x - y
        else:
            print('######### y  为自变量')
            c = w2[0][0] * y - x
        plt.title('Final Cointegration Signal')
        plt.plot(c)
        plt.show()
\end{lstlisting}
在上面的程序中，我们首先像上一节一样，先做出x和y两个非平稳的时间序列信号，然后我们先以x为自变量做一次线性回归，
求出ADF检验的p值和对冲比例，再以y作为自变量做一次线性回归，求出ADF检验的值p和对冲比例，我们取ADF检验的p值较小的
一个作为最终结果，求出线性组合的信号c，最后绘制出其信号典线。\newline
原始信号如下所示：
\begin{figure}[H]
	\caption{原始信号}
	\label{f000049}
	\centering
	\includegraphics[height=5cm]{images/f000049}
\end{figure}
以x为自变量时线性回归运行情况：
\begin{figure}[H]
	\caption{以x为自变量的线性回归}
	\label{f000050}
	\centering
	\includegraphics[height=5cm]{images/f000050}
\end{figure}
以y为自变量时线性回归运行情况：
\begin{figure}[H]
	\caption{以y为自变量时线性回归}
	\label{f000051}
	\centering
	\includegraphics[height=5cm]{images/f000051}
\end{figure}
最后的协整信号结果：
\begin{figure}[H]
	\caption{协整信号}
	\label{f000052}
	\centering
	\includegraphics[height=5cm]{images/f000052}
\end{figure}
程序的运行结果如下所示：
\begin{figure}[H]
	\caption{程序运行结果}
	\label{f000053}
	\centering
	\includegraphics[height=5cm]{images/f000053}
\end{figure}
由于以y为自变量时ADF检验的p值较小，所以取以y为自变量的情况，计算出来的对冲比例为0.51，与实际值0.5非常接近，
这证明我们的算法是正确的。
\subsection{Johansen检验}
我们已经讲述了协整模型理论，可以比较好的处理两个交易对的对冲比例和均值回归的问题。但是这里面有两个问题，首先在协整模
型中，我们假设交易对中的两个标的是线性关系，其次我们只能处理有两个标的的交易对。在本节中，我们将根据\cite{r000001}
投资组合理论，处理标的之间不是线性关系，以及多个交易标的的均值回归策略研发问题。\newline
在实际应用中，我们经常用到的模型是Johansen Test模型，有时也叫VECM模型。在这一节中，我们将来讲解这个模型。Johansen模
型是基于向量自回归VAR模型的。我们以前所讲的自回归模型，都是标量的自回归模型，向量自回归模型定义为：
\begin{equation}
\boldsymbol{x}_{t} = \boldsymbol{\mu} + A_{1}\boldsymbol{x}_{t-1} + ... + A_{p}\boldsymbol{x}_{t-p} + \boldsymbol{w}_{t}
\label{e000063}
\end{equation}
式中$\symbol{\mu}$为序列的均值向量，$\boldsymbol{w}_t$为白噪声向量。接下来我们定义向量误差修正模块VECM（Vector Error Correction Model）：
\begin{equation}
\Delta \boldsymbol{x}_{t}= \boldsymbol{\mu} + A \boldsymbol{x}_{t-1} + \Gamma _{1} \Delta \boldsymbol{x}_{t-1} + ... + \Gamma _{p} \Delta \boldsymbol{x}_{t-p} + \boldsymbol{w}_t
\label{e000064}
\end{equation}
其中A为系数矩阵，$\Gamma _{i}$是各滞后期的系数矩阵。我们对矩阵A进行特征值分解，阶数为$r$，分为以下两种情况：
\begin{itemize}
\item $r=0$：表明没有线性协整模型；
\item $r>0$：至少有$r+1$个序列存在协整关系；
\end{itemize}
在实际应用中，我们取出最大的特征值对应的特征向量，将其元素作为对应序列的协整系数。





\maketitle\begin{center}
\Large \textbf{第5章 卡尔曼滤波}
\end{center}
\begin{abstract}
到目前为止，我们所讨论的基于协整模型的交易对策略，有一个重要的假设，即交易对之间的协整系数是不变的。但是在实际应用中，这些协整系数可能会发生缓慢的改变，如果我们用固定值，可能不会取得最佳的应用效果。在本章中，我们将采用State Space Model来解决这一问题，具体业讲，就是利用卡尔曼滤波技术，将交易对的对冲比例视为系统不可见的状态，将交易对中标的的收益率作为可观察项，利用卡尔曼滤波器的滤波功能，通过不断增加的新观测数据，利用贝叶斯推理，使我们能够更加精准的估计系统不可见状态，在本例中就是交易对的对冲比例。实际上，交易对的对冲比例，不仅会发生缓慢的变化，有时因为监管、宏观经济、市场事件等原因，交易对的对冲比例还可能发生剧烈的变化，这就需要我们识别市场所处状态，识别出市场状态的改变，从而做出更加科学的决策，这部分内容将在下一章隐马可夫模型章节中介绍。aqt005.py
\end{abstract}
\section{卡尔曼滤波}
\subsection{State Space Model概述}
在State Space Model中，我们要研究的对象是环境，这里就是市场。环境会处于某种状态，而且环境所处的状态随着时间而改变。但是我们不能直接观测到环境，我们只能得到一些观察，我们希望通过观察来推测出系统年处的状态。以我们当前的任务为例，我们的环境就是市场上的交易对，而状态就是交易对的对冲比例，而由于各种原因，如市场微观结构等，我们只能得到交易对标的的收益率，其中具有很大的噪声，信噪比很低，我们的任务就是通过观察这些收益率数据，得到交易对的对冲比例。
State Space Model可以用如下图形来表示：
\begin{figure}[H]
	\caption{通用State Space Model}
	\label{f000054}
	\centering
	\includegraphics[height=10cm]{images/f000054}
\end{figure}
图中上面白色的圆圈代表环境的隐藏状态$x_{t}$，蓝色的圆圈代表环境的观测值$y_{t}$，系统会从一个状态转移到另一个状态，可以用一个概率$P(x_{t})x_{t-1}$来表示，环境所处状态决定观察值$P(y_{t} \vert x_{t})$，环境初始时的概率为$P(x_{0})$，根据这些变量的不同特性，我们可以把State Space Model分为四种类型：
\begin{table}[H]
\caption{State Space Model类型}
\label{t000001}
\begin{tabular}{|c|c|c|c|} \hline
名称 & $P(x_{t} \vert x_{t-1})$ & $P(y_{t} \vert x_{t})$ & $P(x_{0})$ \\ \hline  
离散模型（隐马可夫模型） & $A_{x_{t-1}, x_{t}}$ & Any & $\pi$ \\ \hline
线性高斯（卡尔曼滤波器） & $\mathcal{N}\big(  Ax_{t-1}+B, \theta \big)$ & $\mathcal{N}\big(  Hx_{t}+C, R \big)$ & $\mathcal{N}\big(  \mu _{0}, \epsilon _{0} \big)$ \\ \hline
非线性非高斯（粒子滤波器） & $f(x_{t})$ & $g(y_{t})$ & $f_{0}(x_{0})$\\ \hline
\end{tabular}
\end{table}
利用State Space Model可以做三件事情：
\begin{enumerate}
\item 预测：预测下一个到几个时刻的状态值；
\item 滤波：根据当前的观察值，预测系统状态；
\item 平滑：利用过去的观察值，解释过去状态变化情况；
\end{enumerate}
在这一章，我们所研究是线性高斯模型，即卡尔曼滤波器，我们同时会利用贝叶斯推断，通过不断增加的观察值，来逐步精确预测环境状态，在这里就是交易对的对冲比例。\newline
\subsection{数学原理}
在这一部分，我们将简单讲述卡尔曼滤波的数学原理，公式和符号会比较多，但是重点是理解其背后的数据直觉，不必纠结与具体推导过程。\newline
环境状态我们用一个向量来表示$\boldsymbol{x}_{t} \in R^{n}$，由于其会随时间变化，因此我们为其添加了下标$t$，因为卡尔曼滤波是线性高斯模型，当前时刻的状态，是由前一时刻的状态经线性组合再加上高斯噪声所组成，如下所示：
\begin{equation}
\boldsymbol{x}_{t} = A\boldsymbol{x}_{t-1} + \boldsymbol{b} + \boldsymbol{u}_{t}
\label{e000065}
\end{equation}
其中$A \in R{n \times n}$的矩阵，$\boldsymbol{b} \in R^{n}$，$\boldsymbol{w}_{t} \in R^{n}$为高斯白噪声。\newline
系统的观察用$\boldsymbol{y}_t \in R^{m}$表示，其由当前时刻环境状态的线性组合加高斯白噪声组成，如下所示：
\begin{equation}
\boldsymbol{y}_{t} = H\boldsymbol{x}_{t} + \boldsymbol{c} + \boldsymbol{v}_{r}
\label{e000066}
\end{equation}
系统初始状态为高斯分布：
\begin{equation}
\boldsymbol{x}_{0} \sim \mathcal{N} \big( \boldsymbol{\mu}_{0}, \Sigma _{0} \big)
\label{e000067}
\end{equation}
环境状态在t时刻噪声：
\begin{equation}
\boldsymbol{u}_{t} \sim \mathcal{N} \big( 0, \Sigma _{t}^{u} \big)
\label{e000068}
\end{equation}
环境观察在t时刻噪声：
\begin{equation}
\boldsymbol{v}_{t} \sim \mathcal{N} \big( 0, \Sigma _{t}^{v} \big)
\label{e000069}
\end{equation}
\subsection{PyKalman库介绍}
在这一节中，我们将讲述利用卡尔曼滤波来确定交易对的动态对冲比例。我们要研究的交易对为TLT和IEI，其面向美国债券市场，具有相同的市场因素，因此应该具有稳定的协整比例。在本节中我们将使用pykalman库，所以我们先来讲解一下在pykalman库中，卡尔曼滤波的表示方式，主要参考自\cite{r000003}。\newline
我们同样用$x_{t}$来代表环境的隐藏状态，用$y_{t}$来代表对环境的观察，则卡尔曼滤波可以表示为：
\begin{equation}
\boldsymbol{x}_{0} \sim \mathcal{N} \big( \boldsymbol{\mu}_{0}, \Sigma _{0} \big)
\label{e000070}
\end{equation}

\begin{equation}
\boldsymbol{x}_{t} = A_{t-1}\boldsymbol{x}_{t-1} + \boldsymbol{b}_{t-1} + \boldsymbol{\epsilon _{t}^{1}}
\label{e000071}
\end{equation}
\begin{equation}
\boldsymbol{y}_{t} = C_{t}\boldsymbol{x}_{t} + \boldsymbol{d}_{t} + \boldsymbol{\epsilon _{t}^{2}}
\label{e000072}
\end{equation}
\begin{equation}
\boldsymbol{\epsilon _{t}^{1}} \sim \mathcal{N} \big( 0, Q \big)
\label{e000073}
\end{equation}
\begin{equation}
\boldsymbol{\epsilon _{t}^{2}} \sim \mathcal{N} \big( 0, R \big)
\label{e000074}
\end{equation}
式中所用到符号如下所示：
\begin{table}[h]
\caption{PyKalman变量意义}
\label{t000002}
\begin{tabular}{|c|c|c|} \hline
表示 & 模型参数 & 意义 \\ \hline  
$\boldsymbol{\mu} _ {0}$ & initial\_state\_mean & 初始值均值向量 \\ \hline
$\Sigma _{0}$ & initial\_state\_covariance & 初始状态协方差矩阵 \\ \hline
A & transition\_matrices & 转移矩阵 \\ \hline
$\boldsymbol{b}$ & transition\_offsets &  转移偏置值 \\ \hline
Q & transition\_covariance & 转移协方差矩阵（噪声） \\ \hline
C & observation\_matrices & 观察矩阵 \\ \hline
$\boldsymbol{d}$ & observation\_offsets & 观察偏置值 \\ \hline
R & observation\_covariance & 观察协方差矩阵（噪声） \\ \hline
\end{tabular}
\end{table}
卡尔曼滤波中参数的估计是一个比较大的问题，我们可以通过EM（）算法来根据现有的观察和环境状态数据，对参数进行估计。卡尔曼滤波的参数为：
\begin{equation}
\theta = \{A, \boldsymbol{b}, C, \boldsymbol{d}, Q, R, \boldsymbol{\mu}_{0}, \Sigma _{0}\}
\label{e000075}
\end{equation}
我们的目录是：
\begin{equation}
\arg \max _{\theta} P \big( \boldsymbol{y}_{0:T-1};\theta \big)
\label{e000076}
\end{equation}
具体算法比较复杂，作为应用开发者，我们只需要知道这可以通过PyKalman.em(observations)函数来实现就可以了。\newline
\subsection{卡尔曼滤波应用}
我们取到两个ETF的价格数据，并将其保存为文本文件，格式如下所示：
\begin{figure}[H]
	\caption{数据文件格式}
	\label{f000055}
	\centering
	\includegraphics[height=10cm]{images/f000055}
\end{figure}
卡尔曼滤波程序如下所示：
\lstset{language=PYTHON, caption={卡尔曼滤波示例}, label={c000014}}
\begin{lstlisting}
    def hedge_ratio(self):
        etfs = ['TLT', 'IEI']
        start_date = "2010-8-01"
        end_date = "2016-08-01"
        # 获取调整后的收盘价
        dateparse = lambda x: pd.datetime.strptime(x, '%Y-%m-%d')
        prices = pd.read_csv('./work/aqt005_001.txt', encoding='utf-8', parse_dates=['Date'], date_parser=dateparse, index_col='Date')
        # 画散点图
        self.draw_date_coloured_scatterplot(etfs, prices)
        state_means, state_covs = self.calc_slope_intercept_kalman(etfs, prices)
        self.draw_slope_intercept_changes(prices, state_means)
        
    def draw_date_coloured_scatterplot(self, etfs, prices):
        """
        生成散点图，以交易对中两个标的为坐标轴，可以直观观察两个标的间的关系，并且
        采用黄色代表早期数据而红色代表近期数据
        @param etfs 标的字符列表
        @param prices 价格列表，每行为日期、TLT价格、IEI价格
        """
        plen = len(prices)
        colour_map = plt.cm.get_cmap('YlOrRd')
        colours = np.linspace(0.1, 1, plen)
        # 生成散点图
        scatterplot = plt.scatter(
        prices[etfs[0]], prices[etfs[1]],
        s=30, c=colours, cmap=colour_map,
        edgecolor='k', alpha=0.8
        )
        # 添加颜色图表
        colourbar = plt.colorbar(scatterplot)
        colourbar.ax.set_yticklabels(
        [str(p.date()) for p in prices[::plen//9].index]
        )
        plt.xlabel(prices.columns[0])
        plt.ylabel(prices.columns[1])
        plt.show()
        
    def calc_slope_intercept_kalman(self, etfs, prices):
        """
        使用卡尔曼滤波器预测对冲比例
        """
        delta = 1e-5
        mu0 = np.zeros(2)
        sigma0 = np.ones((2, 2))
        Q = delta / (1 - delta) * np.eye(2)
        At = np.eye(2)
        Ct = np.vstack(
            [prices[etfs[0]], np.ones(prices[etfs[0]].shape)]
        ).T[:, np.newaxis]
        R = 1.0
        kf = KalmanFilter(
            n_dim_obs=1,
            n_dim_state=2,
            initial_state_mean=mu0,
            initial_state_covariance=sigma0,
            transition_matrices=At,
            observation_matrices=Ct,
            observation_covariance=R,
            transition_covariance=Q
        )
        
        yt = prices[etfs[1]].values
        #state_means, state_covs = kf.em(observations).filter(observations)
        xt_means, xt_covs = kf.em(yt).filter(yt)
        return xt_means, xt_covs
        
    def draw_slope_intercept_changes(self, prices, state_means):
        """
        绘制斜率和截距
        """
        pd.DataFrame(
            dict(
                slope=state_means[:, 0],
                intercept=state_means[:, 1]
            ), 
            index=prices.index
        ).plot(subplots=True)
        plt.show()
\end{lstlisting}
我们首先从数据文件中读出调整后的收盘价格数据，然后以TFT为横轴，IEI为纵轴，绘制出这两个标的间的对应关系。如下所示：
\begin{figure}[H]
	\caption{散点图}
	\label{f000056}
	\centering
	\includegraphics[height=10cm]{images/f000056}
\end{figure}
由图\ref{f000056}可以看出，二者之间有一个相对稳定的线性关系，这是我们应用交易对交易策略的基础。\newline
我们接着利用卡尔曼滤波来预测对冲比例，为了讲述方便，我们把PyKalman库中的公式重新列在这里：
\begin{equation}
\boldsymbol{x}_{t-1}=A_{t}\boldsymbol{x}_{t-1} + \boldsymbol{b}_{t} + \boldsymbol{\epsilon}_{t}^{1}
\label{e000077}
\end{equation}
\begin{equation}
\boldsymbol{y}_{t}=C_{t}\boldsymbol{x}_{t} + \boldsymbol{d}_{t} + \boldsymbol{\epsilon}_{t}^{2}
\label{e000078}
\end{equation}
\begin{equation}
\boldsymbol{\epsilon}_{t}^{1} \in \mathcal{N} \big( 0, Q \big)
\label{e000079}
\end{equation}
\begin{equation}
\boldsymbol{\epsilon}_{t}^{2} \in \mathcal{N} \big( 0, R \big)
\label{e000080}
\end{equation}
我们将TLT的价格，后面加上1之后形成向量，将当前所有时间点的向量组合到一起，形成的矩阵作为观察矩阵，即公式中的$C_{t}$。观察$y_{t}$在这里为1维，因此初始时其协方差矩阵为1。我们按照给定的初始初始化一个卡尔曼滤波器对象，首先调用em()方法对参数进行估计，然后利估计出的参数，运行滤波功能，得到本时刻系统状态即对冲比例。对于每个时间点，其公式为：
\begin{equation}
y_{t}=\begin{bmatrix}
c_{t} & 1
\end{bmatrix}\begin{bmatrix}
x_{t,1} \\
x_{t,2}
\end{bmatrix} \quad => \quad IEI.price=\begin{bmatrix}
TLT.price & 1
\end{bmatrix}\begin{bmatrix}
slope \\
intercept
\end{bmatrix}
\label{e000081}
\end{equation}
注意：在上式中，我们将截距项$\boldsymbol{d}_{t}$作为向量中的一维来表示，因此式中就没有这一项了。\newline
运行上面的程序，就可以得到各个时间点的斜率和截距，我们接着绘制斜率和截距随时变化的曲线，如下所示：
\begin{figure}[H]
	\caption{对冲比例变化曲线}
	\label{f000057}
	\centering
	\includegraphics[height=10cm]{images/f000057}
\end{figure}
图\ref{f000057}中，上面蓝色的曲线为对冲比例变化曲线，可以看出，对冲比例并不是一成不变的，因此如果我们按照动态变化的对冲比例来设计交易策略，我们可以得到更高的收益。

\maketitle\begin{center}
\Large \textbf{第6章 统计套利策略}
\end{center}
\begin{abstract}
在本章中，我们将利用卡尔曼滤波技术，设计统计套利策略，利用我们的量化交易研究平台进行回测，初步验证策略的正确性。
并将GARCH模型用于实际金融时间序列数据拟合。
\end{abstract}
\section{统计套利策略}
统计套利策略是一种市场中性策略，在实际中有大量应用。
\subsection{数据获取}
我们要研究交易策略，首先要获取历史交易数据，在本节中，我们将讲述如何通过baostock的接口，来获取历史交易数据。我们之所以选择baostock接口，因为baostock可以提供免费的6分钏的日内交易数据，这在免费数据中是很少见的。不过我们这一篇中，我们只研究日线交易数据。baostock接口网站：
\lstset{language=BASH}
\begin{lstlisting}
http://baostock.com/baostock/index.php
\end{lstlisting}
获取股票历史交易记录非常简单，甚至都不用注册用户，例如我们想获取工商银行2006到至2018年数据，根据baostock的规定，工商银行的股票代码为601398.sh，程序如下所示：
\lstset{language=PYTHON, caption={baostock获取股票历史行情数据}, label={c000015}}
\begin{lstlisting}
import baostock as bs
import pandas as pd

class BsCnaDaily(object):
    def __init__(self):
        self.name = 'BsADaily'
        
    def get_history_data(self, stock_code, start_date, end_date):
        '''
        获取A股日线行情历史数据
        @param stock_code 股票代码，如工商银行为：sh.601398
        @param start_date 开始日期，格式yyyy-MM-dd
        @param end_date 结束日期，格式yyyy-MM-dd
        @return 获取成功返回True，否则返回False
        @version v0.0.1 闫涛 2019-04-22
        '''
        lg = bs.login()
        if lg.error_code != '0':
            print('login respond  error_msg:'+lg.error_msg)
            return False, lg.error_msg
        rs = bs.query_history_k_data_plus(stock_code,
                "date,code,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST",
                start_date=start_date, end_date=end_date,
                frequency="d", adjustflag="3")
        if rs.error_code != '0':
            print('query_history_k_data_plus respond  error_msg:'+rs.error_msg)
            return False,rs.error_msg
        data_list = []
        while (rs.error_code == '0') & rs.next():
            data_list.append(rs.get_row_data())
        result = pd.DataFrame(data_list, columns=rs.fields)
        result.to_csv('./data/{0}.csv'.format(stock_code), index=False)
        bs.logout()
        return True
\end{lstlisting}
调用方法如下所示：
\lstset{language=PYTHON, caption={baostock获取股票历史行情数据示例}, label={c000016}}
\begin{lstlisting}
from core.quotation.bs_cna_daily import BsCnaDaily

class TpsaMain(object):
    def __init__(self):
        self.name = 'TpsaMain'
        
    def startup(self):
        print('A股交易对策略')
        bs_cna_daily = BsCnaDaily()
        bs_cna_daily.get_history_data('sh.601398', '2017-01-01', '2017-12-31')
\end{lstlisting}




\section{汇总}
f000022
c000010
e000070






\maketitle\begin{center}
\Large \textbf{第6章 隐马可夫模型}
\end{center}
\begin{abstract}
在本章中我们将首先讲述条件异方差模型GARCH（Generalized AutoRegressive Conditional Heteroskedastic），
并将GARCH模型用于实际金融时间序列数据拟合。aqt002.py
\end{abstract}
\section{隐马可夫模型}



\maketitle\begin{center}
\Large \textbf{第8章 机器学习}
\end{center}
\begin{abstract}
在本章中我们将首先讲述条件异方差模型GARCH（Generalized AutoRegressive Conditional Heteroskedastic），
并将GARCH模型用于实际金融时间序列数据拟合。aqt002.py
\end{abstract}
\section{机器学习}

\maketitle\begin{center}
\Large \textbf{第9章 高频交易}
\end{center}
\begin{abstract}
在本章中我们将首先讲述条件异方差模型GARCH（Generalized AutoRegressive Conditional Heteroskedastic），
并将GARCH模型用于实际金融时间序列数据拟合。aqt002.py
\end{abstract}
\section{高频日内交易}

\maketitle\begin{center}
\Large \textbf{第10章 程序化CTA}
\end{center}
\begin{abstract}
在本章中我们将首先讲述条件异方差模型GARCH（Generalized AutoRegressive Conditional Heteroskedastic），
并将GARCH模型用于实际金融时间序列数据拟合。aqt002.py
\end{abstract}
\section{程序化CTA}

\maketitle\begin{center}
\Large \textbf{第100章 \quad Transformer量化平台}
\end{center}
\begin{abstract}
在本章中我们将首先讲述去年年未在自然语言处理NLP中最流行的架构Transformer，然后介绍Transformer在股价预测方面的应用，接着利用TensorFlow Serving搭建策略服务，我们将该策略服务放到回测平台上进行测试，最后在实盘模拟平台上进行模拟交易。app/tqp
\end{abstract}
\section{Transformer量化平台}
\subsection{Transformer框架}
\subsection{Transformer量化应用}
\subsubsection{搭建colab开发环境}
\paragraph{配置Github}
首先到$https://www.puttygen.com/$网站下载puttygen的windows版本，用于生成访问github项目的公钥和私钥。以管理员身份运行puttygen.exe，点击界面中的"Generate"：
\begin{figure}[H]
	\caption{生成公钥和私钥对}
	\label{f000040}
	\centering
	\includegraphics[height=2cm]{images/f000040}
\end{figure}
在图中的密码为"123456"，点击保存私钥，将其保存到F:/docs/aqp\_github.ppk文件中。\newline
登录https://github.com/yt7589/aqp，在settings=>deploy keys中添加新的Key，将图\ref{f000040}中Public Key框中内容拷贝到下面的文本框中，如下所示：
\begin{figure}[H]
	\caption{将公钥添加到github中}
	\label{f000041}
	\centering
	\includegraphics[height=2cm]{images/f000041}
\end{figure}
接下来在Google colab中创建aqp.ipynb项目，添加代码单元格：
\lstset{language=PYTHON, caption={初始化github私钥}, label={c000010}}
\begin{lstlisting}
key = \
'''
PuTTY-User-Key-File-2: ssh-rsa
Encryption: aes256-cbc
Comment: rsa-key-20190411
Public-Lines: 6
AAAAB3NzaC1yc2EAAAABJQAAAQEAgWDxZNQtkqfNPnP1rHHIXx+Wi2HUL35RzXfo
T21fc+/gxjOQ7zG+V/KkTY0ZSuZBrdGhKRosamrBsaR+PrC3pqLNhOlFdUhsxvMg
YaLM79KUiirFp3dLHOqud4tuWE+BybsYmJA0m7sBJ6aUNXEoX8h5Nxy9VfHzfRIP
0ekeAA6vkd2PA5jy7AsbFCW1mwmBcu0ptAu3+sjLeIspsa0ED3vivUsnMeWQ87ll
DH7h3SC7InUlZLqr/gVKBrPnDSecAhVTTaoUG6PtTF0UkYYXixs1+daSBtEV568n
rRNV2cUkYseMnKwHdccXV2iVraHd11WsxJr2UDNt5nkKcpUkoQ==
Private-Lines: 14
qBX9VNU5GZoUAPvntTt8IRI7YqXfVgmKNVWDeyRFRGBlBsMVsU/o1AEm2pO9plHz
6vAuIje1fg70kDXcBuRCBiEJZ8IDdkNR5nqcgSFEnn2e/5UpisrA4FmGD99sSmWl
XJQAUEw5d7rxpQukiF6H19cJI+9e5vj9WIIKrCCXDawJyKaMQw0nn1zMJHsv6o21
MFlZqD8UUP4eoYrzRk2ga99O99b1MdYIwo2dUR40RQUGshKqIKdLHyiSBuy3gQm1
bmHNyrdMqCAN/88wadQRZvuyRudVXQAGbgYvDgZZV00EbiSOKPpmneK6DvgPaXea
J/1F+wAoZY8LsXZWlP2o44DjeJNmtc9eVPoR4b/hrG5fyMt9OmnCmL6Te6yue59L
pjH1gyvIMuoo3La71y8mlLKH8Hnb+bM5z6Ew7f/oMXzP9fNEdIsDN11L4WY9Gju1
GY0TUzi4h4li4K4Khzx1lOPDyaJahArx5iobD5xbemb4kj4OMRdsuQDqD7g32zVo
e8vVMgv8j3bzIpCAYmAmVhxslcpiFEUwjRtR6eyz7OL7g9IpkeG5fezGYMOLXxko
A1SWbIwqfODQhPJA1Pj3vnys8XVeQU04hplqyn955bwxl4abhVR3Q05E7DMYfdrR
f+a2VI4tAoWi7LCgskDnZ5754P3mUFkxSbILLt6tW+1Y4jbmPj6tP8GUI3Dm3zK6
qQAGkp3U9QeYlwsbO8lkTuWcW+NEyTfekjxnLtt1KLZufsKRDD1Dk4vQiXjKRCOU
UgjZ2Uui24d6N6ug/uiVNuxrDuZbpWpp2SYZEiuQCNhu3br+Q/+ZEZsmgslLewnr
ocK3qv7FUKq/Jg1QrjOmLq/RF1hVr+XcXzubiDcEdmZpFzsn7/VKHk/Jvv4f6IOd
Private-MAC: e16aabf8a23afa92f89fdeb3f5b2d36c20afb0ff

'''
! mkdir -p /root/.ssh
with open(r'/root/.ssh/id_rsa', 'w', encoding='utf8') as fh:
    fh.write(key)
! chmod 600 /root/.ssh/id_rsa
! ssh-keyscan gitlab.com >> /root/.ssh/known_hosts
\end{lstlisting}
在上面的代码中，先取出私钥文件中的内容，然后创建/root/.ssh目录，将私钥内容保存到/root/.ssh/id\_rsa文件中。运行上面的代码单元格，如果不报错就证明可以运行成功了。
\paragraph{下载源码文件}
可以通过如下命令获取github上的源码：
\lstset{language=BASH}
\begin{lstlisting}
!git clone https://github.com/yt7589/aqp.git
\end{lstlisting}
\paragraph{配置Google Drive文件系统}
我们需要读取保存在Google Drive中的数据集文件，因此我们需要建立一些特别工具来完成下面的内容。我们首先初始化环境：
\lstset{language=PYTHON, caption={初始化环境}, label={c000011}}
\begin{lstlisting}
from google.colab import drive
drive.mount('/content/drive')
\end{lstlisting}
这时需要访问提示中的网站，同意授权，将页面中授权码拷贝，将授权码粘贴到编辑框中并回车，然后我们就可像使用正常的目录一样来读写文件了。
\lstset{language=PYTHON, caption={初始化环境}, label={c000012}}
\begin{lstlisting}
with open('/content/drive/My Drive/fbm/README.md', 'r') as fd:
  readme = fd.read()
  print(readme)
\end{lstlisting}
其中fbm/是我们在Google Drive中创建的目录，使用这种方法，也不会出现中文乱码的问题。
具体用Transformer来预测股票价格的代码，colab的地址为：
\lstset{language=BASH}
\begin{lstlisting}
https://colab.research.google.com/drive/1PVwlbHfrndFhnNIjSLWaD1bsr-5olV1d#scrollTo=7s5HTXF9xall。
参考：
\lstset{language=BASH}
\begin{lstlisting}
https://github.com/llSourcell/Make_Money_with_Tensorflow_2.0/issues
\end{lstlisting}
\subsection{tqp平台}
\subsection{策略回测}
\subsection{实盘模拟}



参考文献：
\cite{ex1}---\cite{ex2}---\cite{refa001}

\newpage

\bibliographystyle{plainnat}
\bibliography{nips}

\appendix


\end{document}
